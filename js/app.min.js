// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var storage;
var summary;
var response;
var request;
var utils;
var map;

var autocomplete = {};

autocomplete._paramValueEverywhere = [
    'depth', 'count', 'forbidden_uris[]', 'filter', 'bss_stands'
];

autocomplete._collections = [
    'addresses', 'commercial_modes', 'companies', 'contributors', 'coord', 'coverage',
    'datasets', 'disruptions', 'lines', 'networks', 'places', 'poi_types', 'pois',
    'physical_modes', 'routes', 'stop_areas', 'stop_points', 'vehicle_journeys'
];

autocomplete._additionalFeatures = [
    'departures', 'journeys', 'places_nearby', 'pt_objects', 'route_schedules',
    'stop_schedules', 'arrivals', 'isochrones', 'heat_maps', 'traffic_reports',
    'line_reports', 'equipment_reports', 'terminus_schedules', 'freefloatings_nearby', 'vehicle_positions'
];

autocomplete._paramJourneyCommon = [
    'from', 'to', 'datetime','traveler_type', 'data_freshness',
    'first_section_mode[]', 'last_section_mode[]', 'allowed_id[]'
].concat(autocomplete._paramValueEverywhere);

autocomplete._depArrParams = [
    'from_datetime', 'duration', 'data_freshness'
].concat(autocomplete._paramValueEverywhere);

autocomplete._schedulesParams = [
    'from_datetime', 'duration', 'items_per_schedule', 'data_freshness'
].concat(autocomplete._paramValueEverywhere);

autocomplete._placesParams = [
    'q', 'type[]', 'admin_uri[]', 'from'
].concat(autocomplete._paramValueEverywhere);

autocomplete._fallbackMode = ['walking', 'car', 'bike', 'bss'];

autocomplete._booleanValues = ['true', 'false'];

autocomplete.autocompleteTree = {
    pathKey: {
        empty : ['coverage', 'places', 'coord'],
        all : autocomplete._collections,
    },
    features: {
        all: autocomplete._collections.concat(autocomplete._additionalFeatures),
    },
    paramKey: {
        arrivals: autocomplete._depArrParams,
        coord: autocomplete._paramValueEverywhere,
        coverage: autocomplete._paramValueEverywhere,
        departures: autocomplete._depArrParams,
        journeys: ['datetime_represents'].concat(autocomplete._paramJourneyCommon),
        isochrones: ['max_duration', 'min_duration', 'boundary_duration[]'].concat(autocomplete._paramJourneyCommon),
        heat_maps: ['max_duration', 'resolution'].concat(autocomplete._paramJourneyCommon),
        lines: autocomplete._paramValueEverywhere,
        places_nearby: autocomplete._placesParams,
        places: autocomplete._placesParams,
        pois: ['distance'].concat(autocomplete._paramValueEverywhere),
        pt_objects: ['q', 'type[]'].concat(autocomplete._paramValueEverywhere),
        stop_areas: autocomplete._paramValueEverywhere,
        stop_points: autocomplete._paramValueEverywhere,
        routes: autocomplete._paramValueEverywhere,
        route_schedules: autocomplete._schedulesParams,
        stop_schedules: autocomplete._schedulesParams,
        empty: autocomplete._paramValueEverywhere,
    },
    paramValue : {
        traveler_type : ['luggage', 'standard', 'fast_walker', 'slow_walker'],
        datetime_represents : ['arrival', 'departure'],
        data_freshness: ['base_schedule', 'realtime'],
        debug: autocomplete._booleanValues,
        wheelchair: autocomplete._booleanValues,
        disable_geojson: autocomplete._booleanValues,
        bss_stands: autocomplete._booleanValues,
        'first_section_mode[]': autocomplete._fallbackMode,
        'last_section_mode[]': autocomplete._fallbackMode,
    }
};

autocomplete.apiAutocomplete = function() {
    var input = $('#api input.api');
    var apis = storage.getApis();
    autocomplete._customAutocompleteHelper(input, apis, {
        close: request.setSaveTokenButtonStatus,
        select: function (event, ui) {
            $(input).val(ui.item.value);
            $('#token input.token').val(storage.getToken(ui.item.value));
        }
    });
};

autocomplete.valueAutoComplete = function (input, key) {
    var manualFallback = function() {
        // if no autocomplete is available, we use the old static autocomplete system
        if (utils.isDatetimeType(key)) {
            autocomplete._makeDatetime(input);
        } else if (key in autocomplete.autocompleteTree.paramValue){
            autocomplete._customAutocompleteHelper(input, autocomplete.autocompleteTree.paramValue[key]);
        } else if (autocomplete.staticAutocompleteTypes.indexOf(key) > -1) {
            autocomplete.staticAutocomplete(input, key);
        } else if (key in autocomplete.dynamicAutocompleteTypes) {
            autocomplete.dynamicAutocomplete(input, key);
        }
    };
    // we use the swagger definition only for the parameters
    if (! $(input).hasClass('parameters')) {
        return manualFallback();
    }
    autocomplete.swaggerAutocomplete({
        input: input,
        extractResult: function(swagger_response) {
            var param = swagger_response.get.parameters.find(function(e) { return e.name === key; });
            if (! param) {
                manualFallback();
                return null;
            }
            param = param.type === 'array' ? param.items : param;
            if (param.format === 'date-time' || param.format === 'navitia-date-time') {
                autocomplete._makeDatetime(input);
                return null;
            }
            if (param.type === 'boolean') {
                return autocomplete._booleanValues;
            }
            if (param.format === 'place') {
                new autocomplete.Place().autocomplete(input);
                return null;
            }
            if (param.format === 'pt-object') {
                new autocomplete.PtObject().autocomplete(input);
                return null;
            }
            if ('enum' in param) {
                return param.enum;
            }

            manualFallback();
            return null;
        },
        onError: manualFallback
    });
};

autocomplete.getSwaggerParams = function(swagger) {
    return $.map(swagger.get.parameters, function (p) {
        if (p.in !== 'query') {
            return null;
        }
        return p.name;
    });
};

autocomplete.swaggerAutocomplete = function(args) {
    var input = args.input;
    var old_req = '';
    var old_token = '';
    var handle = function() {
        var token = $('#token input.token').val();
        var urlElements = request.urlElements();
        var req = urlElements.api + urlElements.path + '/' + urlElements.feature + '?schema=true';
        if (req !== old_req || token !== old_token) {
            old_req = req;
            old_token = token;
            if ($(input).autocomplete('instance')) {
                // be sure that out-of-date autocompletion will not be active
                $(input).autocomplete('destroy');
            }
            $(input).parent().find('.tooltips').empty();
            $.ajax({
                headers: utils.manageToken(token),
                dataType: 'json',
                method: 'OPTIONS',
                url: req
            }).done(function(data) {
                    var res = args.extractResult(data);
                    if (res === null) {
                        //nothing to do
                        return;
                    }
                    res = res.sort();
                    $(input).autocomplete({
                        close: function() { request.updateUrl($(input)[0]); },
                        select: function(event, ui) { $(input).val(ui.item.value).change(); },
                        source: res,
                        minLength: 0,
                        scroll: true,
                        delay: 0
                    });
                    $(input).autocomplete('enable');
                    if ($(input).is(':focus') && $(input).autocomplete('instance')) {
                        $(input).autocomplete('search', '');
                    }
                }
            ).fail(function(data, status, error) {
                if (data.responseText !== '') {
                    utils.notifyOnError('Autocomplete', req, data, status, error);
                    console.warn('error on swagger call for req ' + req, data, error);// jshint ignore:line
                }
                args.onError(data);
            });
        } else if ($(input).is(':focus') && $(input).autocomplete('instance')) {
            $(input).autocomplete('search', '');
        }
    };
    handle();
    $(input).focus(handle);
};

autocomplete.paramKey = function(input, type) {
    autocomplete.swaggerAutocomplete({
        input: input,
        extractResult: function(swagger_response) {
            return autocomplete.getSwaggerParams(swagger_response);
        },
        onError: function() {
            // if no autocomplete is available, we use the old static autocomplete system
            // TODO: when all navitia api are defined by swagger, we can remove this
            var feature = $('#featureInput').val();
            var source = autocomplete.autocompleteTree[type][feature] || autocomplete.autocompleteTree[type].empty || [];
            autocomplete._customAutocompleteHelper(input, source, {
                select: function(event, ui) { $(input).val(ui.item.value).change(); }
            });
        }
    });
};

autocomplete.addKeyAutocomplete = function(input, type) {
    var source;
    if (type === 'pathKey' && ! $('#pathFrame').find('.value').length) {
        source = this.autocompleteTree[type].empty;
    } else if (type === 'paramKey'){
        return autocomplete.paramKey(input, type);
    } else {
        source = this.autocompleteTree[type].all;
    }
    source = source || [];
    autocomplete._customAutocompleteHelper(input, source, {
        select: function(event, ui) { $(input).val(ui.item.value).change(); }
    });
};

autocomplete.staticAutocompleteTypes = [
    'coverage',
    'physical_modes',
    'poi_types',
];

autocomplete.staticAutocomplete = function(input, staticType) {
    var old_req = '';
    var old_token = '';
    var handle = function() {
        var api = $('#api input.api').val();
        var token = $('#token input.token').val();
        var cov = request.getCoverage();
        var req = api +  '/coverage/';
        if (staticType !== 'coverage') {
            req +=  cov + '/' + staticType;
        }
        req += '?disable_geojson=true';
        if (req !== old_req || token !== old_token) {
            old_req = req;
            old_token = token;
            autocomplete.updateStaticAutocomplete(input, staticType, req, token);
        } else if ($(input).is(':focus') && $(input).autocomplete('instance')) {
            $(input).autocomplete('search', '');
        }
    };
    handle();
    $(input).focus(handle);
};

autocomplete.updateStaticAutocomplete = function(input, staticType, req, token) {
    if ($(input).autocomplete('instance')) {
        // be shure that out-of-date autocompletion will not be active
        $(input).autocomplete('destroy');
    }
    $(input).parent().find('.tooltips').empty();
    $.ajax({
        headers: utils.manageToken(token),
        dataType: 'json',
        url: req,
        success: function(data) {
            var res = [];
            staticType = (staticType==='coverage') ? 'regions' :  staticType;
            data[staticType].forEach(function(elt) {
                var s = summary.run(new response.Context(data), utils.getType(staticType), elt);
                res.push({ value: elt.id, label: s.textContent, desc: s });
            });
            res = res.sort(function(a, b) {
                if (a.label < b.label) { return -1; }
                if (a.label > b.label) { return 1; }
                return 0;
            });
            $(input).autocomplete({
                close: function() { request.updateUrl($(input)[0]); },
                source: res,
                minLength: 0,
                scroll: true,
                delay: 0
            }).autocomplete('instance')._renderItem = function(ul, item) {
                return $('<li>').append(item.desc).appendTo(ul);
            };
            $(input).autocomplete('enable');
            if ($(input).is(':focus') && $(input).autocomplete('instance')) {
                $(input).autocomplete('search', '');
            }
        },
        error: function(data, status, error) {
            utils.notifyOnError('Autocomplete', req, data, status, error);
        }
    });
};

autocomplete.getUrlWithCov = function() {
    var url = $('#api input.api').val();
    var cov = request.getCoverage();
    url += cov ? ('/coverage/' + cov) : '';
    return url;
};

autocomplete.AbstractObject = function(types) {
    this.types = types || [];
};
autocomplete.AbstractObject.prototype.autocompleteUrl = function(term) {
    var url = autocomplete.getUrlWithCov();
    url += '/' + this.api + '?display_geojson=false&q=' + encodeURIComponent(term);
    this.types.forEach(function(type) {
        url += '&type[]=' + type;
    });
    return url;
};
autocomplete.AbstractObject.prototype.objectUrl = function(term) {
    var url = autocomplete.getUrlWithCov();
    url += '/' + this.api + '/' + encodeURIComponent(term) + '?display_geojson=false';
    return url;
};
autocomplete.AbstractObject.prototype.source = function(urlMethod) {
    if (urlMethod === undefined) { urlMethod = 'autocompleteUrl'; }
    var self = this;
    return function(req, res) {
        var token = $('#token input.token').val();
        var url = self[urlMethod](req.term);
        if (! url) { return res([]); }
        $.ajax({
            url: url,
            headers: utils.manageToken(token),
            success: function (data) {
                var result = [];
                var key = response.responseCollectionName(data);
                var search = key ? data[key] : [];
                var type = utils.getType(key);
                if (search) {
                    search.forEach(function(s) {
                        var sum = summary.run(new response.Context(data), type, s);
                        result.push({ value: s.id, label: sum });
                    });
                }
                res(result);
            },
            error: function(data, status, error) {
                res([]);
                utils.notifyOnError('Autocomplete', url, data, status, error);
            }
        });
    };
};
autocomplete.AbstractObject.prototype.describe = function(elt) {
    $(elt).autocomplete('option', 'source', this.source('objectUrl'));
    $(elt).autocomplete('search');
    $(elt).autocomplete('option', 'source', this.source());
};
autocomplete.AbstractObject.prototype.autocomplete = function (elt) {
    var self = this;
    $(elt).autocomplete({
        delay: 200,
        close: function() { request.updateUrl($(elt)[0]); },
        source: self.source()
    }).focus(function() {
        self.describe(this);
    }).hover(function() {
        if (! $(this).is(':focus')) { self.describe(this); }
    }, function() {
        if (! $(this).is(':focus')) { $(this).autocomplete('close'); }
    }).autocomplete('instance')._renderItem = function(ul, item) {
        return $('<li>').append(item.label).appendTo(ul);
    };
};

autocomplete.PtObject = function(types) {
    autocomplete.AbstractObject.call(this, types);
};
autocomplete.PtObject.prototype = Object.create(autocomplete.AbstractObject.prototype);
autocomplete.PtObject.prototype.api = 'pt_objects';
autocomplete.PtObject.prototype.objectUrl = function(term) {
    // /pt_objects/{pt_object.id} is not supported yet by navitia,
    // using the type if there is no ambiguity.
    if (this.types.length === 1) {
        var url = autocomplete.getUrlWithCov();
        url += '/' + this.types[0] + 's/' + encodeURIComponent(term) + '?display_geojson=false';
        return url;
    }
    return null;
};

autocomplete.Place = function(types) {
    autocomplete.AbstractObject.call(this, types);
};
autocomplete.Place.prototype = Object.create(autocomplete.AbstractObject.prototype);
autocomplete.Place.prototype.api = 'places';
autocomplete.Place.prototype.autocomplete = function(elt) {
    if (!this.types.length || this.types.indexOf('address') !== -1) {
        var tooltips = $(elt).parent().find('.tooltips');

        $('<button/>')
            .html('<img src="img/pictos/MapMarker.svg" alt="map">')
            .click(function() {
                var div = $('<div/>').appendTo('body');
                map.createMap(function(m) {
                    m.on('click', function(e) {
                        var coord = sprintf('%.5f;%.5f', e.latlng.lng, e.latlng.lat);
                        $(elt).val(coord).select();
                        div.children().trigger('npg:remove');
                        div.remove();
                    });
                    return storage.getBounds();
                }).css({
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    height: '100%',
                    width: '100%',
                }).appendTo(div);
                utils.notifyInfo('Click on the map to set the location.');
            }).prependTo(tooltips);

        $('<button/>')
            .html('<img src="img/pictos/Location.svg" alt="location">')
            .click(function() {
                utils.notifyInfo('Getting current position...');
                navigator.geolocation.getCurrentPosition(function(pos) {
                    var coord = sprintf('%.5f;%.5f', pos.coords.longitude, pos.coords.latitude);
                    utils.notifyInfo('Got location: ' + coord);
                    $(elt).val(coord).select();
                }, function(error) {
                    utils.notifyWarn(sprintf('geolocation error: %s', error.message));
                }, {
                    enableHighAccuracy: false,
                    timeout: 60000,//1min
                    maximumAge: 300000,//5min
                });
            }).prependTo(tooltips);
    }
    return autocomplete.AbstractObject.prototype.autocomplete.call(this, elt);
};

autocomplete.dynamicAutocompleteTypes = {
    'addresses': new autocomplete.Place(['address']),
    'administrative_regions': new autocomplete.Place(['administrative_region']),
    'commercial_modes': new autocomplete.PtObject(['commercial_mode']),
    'coord': new autocomplete.Place(['address']),
    'forbidden_uris[]': new autocomplete.PtObject(),
    'allowed_id[]': new autocomplete.PtObject(),
    'lines': new autocomplete.PtObject(['line']),
    'networks': new autocomplete.PtObject(['network']),
    'places': new autocomplete.Place(),
    'pois': new autocomplete.Place(['poi']),
    'routes': new autocomplete.PtObject(['route']),
    'stop_areas': new autocomplete.Place(['stop_area']),
    'stop_points': new autocomplete.Place(['stop_point']),
    'from': new autocomplete.Place(),
    'to': new autocomplete.Place(),
};

autocomplete.dynamicAutocomplete = function (elt, dynamicType) {
    autocomplete.dynamicAutocompleteTypes[dynamicType].autocomplete(elt);
};

autocomplete._customAutocompleteHelper = function(input, source, customOptions) {
    if (source.length && source[0] instanceof Object) {
        source = source.sort(function(a, b) {
            if (a.value < b.value) { return -1; }
            if (a.value > b.value) { return 1; }
            return 0;
        });
    } else {
        source = source.sort();
    }
    var options = {
        close: function() { request.updateUrl($(input)[0]); },
        source: source,
        minLength: 0,
        scroll: true,
        delay: 0
    };
    if (customOptions) { $.extend(true, options, customOptions); }
    $(input).autocomplete(options).focus(function() {
        if ($(input).autocomplete('instance')) {
            $(this).autocomplete('search', '');
        }
    });
    if ($(input).is(':focus')) {
        $(input).focus();
    }
};

autocomplete._makeDatetime = function(elt) {
    $(elt).datetimepicker({
        dateFormat: 'yymmdd',
        timeFormat: 'HHmmss',
        timeInput: true,
        separator: 'T',
        controlType: 'select',
        oneLine: true,
    });
    if ($(elt).is(':focus')) {
        // we need to get the focus again to update the datepicker
        $(elt).focus();
    }
};

$(document).ready(function() {
    // We want to do whatever we want by hand!
    $.datepicker._doKeyPress = function () { return true; };
});

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var summary;
var utils;

var extended = {};

// the object that contains the function to make the extended views
extended.make = {};

extended.make.response = function(context, json) {
    var result = $('<div class="list"/>');

    if ('full_response' in json) {
        result.append(response.render(context, json.full_response, 'response', 'full_response'));
    }

    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }

    if(json.address) {
        // We can have a single address if we use the '/coord/{long;lat}' endpoint
        result.append(response.render(context, json.address, 'address', 'address'));
    } else {
        // Let's try to deduce the response type
        var key = response.responseCollectionName(json);
        var objs = key ? json[key] : [];
        var type = utils.getType(key);
        if (type) {
            objs.forEach(function(obj, i) {
                result.append(response.render(context, obj, type, key, i));
            });
        }
        
        if (type !== 'disruption' && $.isArray(json.disruptions)) {
            json.disruptions.forEach(function(disruption, i) {
                result.append(response.render(context, disruption, 'disruption', 'disruptions', i));
            });
        }
    }

    (json.notes || []).forEach(function(note, i) {
        result.append(response.render(context, note, 'note', 'notes', i));
    });

    (json.terminus || []).forEach(function(terminus, i) {
        result.append(response.render(context, terminus, 'terminus', 'terminus', i));
    });

    (json.feed_publishers || []).forEach(function(feed_publisher, i) {
        result.append(response.render(context, feed_publisher, 'contributor', 'feed_publishers', i));
    });

    (json.warnings || []).forEach(function(warning, i) {
        result.append(response.render(context, warning, 'warning', 'warnings', i));
    });

    if (json.context) {
        result.append(response.render(context, json.context, 'context', 'context'));
    }

    return result;
};

extended.make.journey = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if ('tags' in json && json.tags.length > 0) {
        result.append(response.render(context, json.tags, 'tags', 'tags'));
    }
    if (json.co2_emission && json.co2_emission.value) {
        result.append(response.render(context, json.co2_emission, 'co2_emission', 'co2_emission'));
    }
    if (json.distances) {
        result.append(response.render(context, json.distances, 'distances', 'distances'));
    }

    if (json.from) {
        result.append(response.render(context, json.from, 'place', 'from'));
    }
    if (json.to) {
        result.append(response.render(context, json.to, 'place', 'to'));
    }
    if (json.sections) {
        json.sections.forEach(function(section, i) {
            result.append(response.render(context, section, 'section', 'sections', i));
        });
    }
    return result;
};

extended.make.section = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (json.display_informations &&
        Array.isArray(json.display_informations.links) &&
        json.display_informations.links.length) {
        result.append(response.render(context, json.display_informations.links, 'links', 'display_informations.links'));
    }
    if (json.display_informations &&
        Array.isArray(json.display_informations.equipments) &&
        json.display_informations.equipments.length) {
        result.append(response.render(context,
                                      json.display_informations.equipments,
                                      'equipments',
                                      'display_informations.equipments'));
    }
    if (json.co2_emission && json.co2_emission.value) {
        result.append(response.render(context, json.co2_emission, 'co2_emission', 'co2_emission'));
    }
    if (json.from) {
        result.append(response.render(context, json.from, 'place', 'from'));
    }
    if (json.to) {
        result.append(response.render(context, json.to, 'place', 'to'));
    }
    if (json.path) {
        result.append(response.render(context, json, 'path', 'paths'));
    }
    if (json.elevations) {
        result.append(response.render(context, json.elevations, 'elevations', 'elevations'));
    }
    if (json.vias) {
        result.append(response.render(context, json, 'vias', 'vias'));
    }
    (json.ridesharing_journeys || []).forEach(function(j, i) {
        result.append(response.render(context, j, 'journey', 'ridesharing_journeys', i));
    });
    if (json.stop_date_times) {
        json.stop_date_times.forEach(function(stop_date_time, i) {
            result.append(response.render(context, stop_date_time, 'stop_date_time', 'stop_date_times', i));
        });
    }
    return result;
};

extended.make.stop_schedule = function(context, json) {
    return extended.defaultStopSchedule(context, json);
};

extended.make.route_schedule = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (Array.isArray(json.display_informations.links) && json.display_informations.links.length) {
        result.append(response.render(context, json.display_informations.links, 'links', 'display_informations.links'));
    }
    result.append(response.render(context, json.table, 'table', 'table'));
    return result;
};


extended.make.vehicle_position = function(context, json) {
    var result = $('<div class="list"/>');
    result.append(response.render(context, json.line, 'line', 'line'));
    if (json.vehicle_journey_positions) {
        json.vehicle_journey_positions.forEach(function(vehicle_journey_position, i) {
            result.append(response.render(context, vehicle_journey_position, 'vehicle_journey_position',
            'vehicle_journey_position', i));
        });
    }
    return result;
};

extended.make.departure = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (Array.isArray(json.display_informations.links) && json.display_informations.links.length) {
        result.append(response.render(context, json.display_informations.links, 'links', 'display_informations.links'));
    }
    result.append(response.render(context, json.route, 'route', 'route'));
    result.append(response.render(context, json.stop_point, 'stop_point', 'stop_point'));
    return result;
};
extended.make.arrival = extended.make.departure;

extended.make.table = function(context, json) {
    var result = $('<div class="table"/>');
    var table = $('<table/>');
    // Add the data rows
    json.rows.forEach(function(route_schedule) {
        var row = $('<tr/>');
        var cellName = $('<td />').addClass('stop-point');
        cellName.text(route_schedule.stop_point.name);
        row.append(cellName);
        route_schedule.date_times.forEach(function(route_schedule) {
            var cellValue = $('<td />').addClass('time');
            cellValue.html(summary.formatTime(route_schedule.date_time));
            row.append(cellValue);
        });
        table.append(row);
    });
    result.append(table);
    return result;
};

extended.make.poi = function(context, json) {
    var result = extended.defaultExtended(context, 'poi', json);
    if (json.stands) {
        result.append(response.render(context, json.stands, 'stands', 'stands'));
    }
    if (json.car_park) {
        result.append(response.render(context, json.car_park, 'car_park', 'car_park'));
    }
    return result;
};

extended.make.stop_point = function(context, json) {
    var result = extended.defaultExtended(context, 'stop_point', json);
    if (Array.isArray(json.equipments) && json.equipments.length) {
        result.append(response.render(context, json.equipments, 'equipments', 'equipments'));
    }
    if (json.access_points) {
        json.access_points.forEach(function(section, i) {
            result.append(response.render(context, section, 'access_point', 'access_point', i));
        });
    }
    return result;
};

extended.make.disruption = function(context, json) {
    var res = $('<div class="list"/>');
    (json.application_patterns || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'application_pattern', 'application_patterns', i));
    });

    if (json.application_periods) {
        res.append(response.render(context,
                                   json.application_periods,
                                   'application_periods',
                                   'application_periods'));
    }
    (json.messages || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'message', 'messages', i));
    });
    (json.impacted_objects || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'impacted_object', 'impacted_objects', i));
    });
    return res;
};

extended.make.impacted_object = function(context, json) {
    var res = $('<div class="list"/>');
    if (json.impacted_section) {
        res.append(response.render(context, json.impacted_section, 'impacted_section', 'impacted_section'));
    }
    res.append(response.render(context, json.pt_object, 'pt_object', 'pt_object'));
    if ($.isArray(json.impacted_stops)) {
        json.impacted_stops.forEach(function(obj, i) {
            res.append(response.render(context, obj, 'impacted_stop', 'impacted_stops', i));
        });
    }
    return res;
};

extended.make.impacted_section = function(context, json) {
    var res = $('<div class="list"/>')
        .append(response.render(context, json.from, 'pt_object', 'from'))
        .append(response.render(context, json.to, 'pt_object', 'to'));
    (json.routes || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'route', 'routes', i));
    });
    return res;
};

extended.make.connection = function(context, json) {
    return $('<div class="list"/>')
        .append(response.render(context, json.origin, 'stop_point', 'origin'))
        .append(response.render(context, json.destination, 'stop_point', 'destination'));
};

extended.make.links = function(context, json) {
    var res = $('<div class="list"/>');
    json.forEach(function(link) {
        var obj = context.followInternalLink(link);
        if (obj) {
            res.append(response.render(context, obj.obj, utils.getType(link.rel), '> ' + obj.path));
        }
    });
    return res;
};

extended.make.line_report = function(context, json) {
    var res = $('<div class="list"/>');
    res.append(response.render(context, json.line, 'line', 'line'));
    json.pt_objects.forEach(function(obj, i) {
        res.append(response.render(context, obj, 'pt_object', 'pt_objects', i));
    });
    return res;
};

extended.make.vehicle_journey = function(context, json) {
    var res = extended.defaultExtended(context, 'vehicle_journey', json);
    (json.stop_times || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'stop_time', 'stop_times', i));
    });
    return res;
};

extended.make.equipment_report = function(context, json) {
    var res = $('<div/>');
    (json.stop_area_equipments || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'stop_area_equipment', 'stop_area_equipments', i));
    });
    return res;
};

extended.make.stop_area_equipment = function(context, json) {
    var res = extended.defaultExtended(context, 'equipment_details', json);
    (json.equipment_details || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'equipment_detail', 'equipment_details', i));
    });
    return res;
};

extended.make.path = function(context, json) {
    var res = extended.defaultExtended(context, 'paths', json);
    (json.path || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'instruction', 'paths', i));
    });
    return res;
};

extended.make.via = function(context, json) {
    var res = $('<div/>');
    res.append(response.render(context, json.access_point, 'access_point', 'access_point'));
    return res;
};

extended.make.vias = function(context, json) {
    var res = $('<div/>');
    (json.vias || []).forEach(function(obj, i) {
        res.append(response.render(context, obj, 'via', 'via', i));
    });
    return res;
};

extended.make.terminus_schedule = function(context, json) {
    return extended.defaultStopSchedule(context, json);
};

extended.defaultStopSchedule = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (Array.isArray(json.display_informations.links) && json.display_informations.links.length) {
        result.append(response.render(context, json.display_informations.links, 'links', 'display_informations.links'));
    }
    if (json.first_datetime) {
        result.append(response.render(context, json.first_datetime, 'date_time', 'first_datetime'));
    }
    if (json.last_datetime) {
        result.append(response.render(context, json.last_datetime, 'date_time', 'last_datetime'));
    }
    json.date_times.forEach(function(date_time, i) {
        result.append(response.render(context, date_time, 'date_time', 'date_times', i));
    });
    return result;
};

//
// add your extended view by adding:
//   extended.make.{type} = function(context, json) { ... }

extended.defaultExtended = function(context, type, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (Array.isArray(json.codes) && json.codes.length) {
        result.append(response.render(context, json.codes, 'codes', 'codes'));
    }
    for (var key in json) {
        if (! (utils.getType(key) in context.links)) { continue; }
        if ($.isArray(json[key])) {
            json[key].forEach(function(obj, i) {
                result.append(response.render(context, obj, utils.getType(key), key, i));
            });
        } else {
            result.append(response.render(context, json[key], utils.getType(key), key));
        }
    }
    return result;
};

extended.has = {};
extended.has.section = function(context, json) {
    return Boolean(json.from) || Boolean(json.to) || Boolean(json.stop_date_times);
};
extended.has.poi = function(context, json) {
    return extended.hasDefaultExtended(context, json);
};
extended.has.links = function(context, json) {
    for (var i = 0; i < json.length; ++i) {
        if (context.followInternalLink(json[i])) {
            return true;
        }
    }
    return false;
};
extended.hasDefaultExtended = function(context, json) {
    if (! (json instanceof Object)) { return false; }
    if (Array.isArray(json.links) && json.links.length) { return true; }
    if (Array.isArray(json.codes) && json.codes.length) { return true; }
    for (var key in json) {
        if (utils.getType(key) in context.links) { return true; }
    }
    return false;
};

extended.hasExtended = function(context, type, json) {
    try {
        if (type in extended.make) {
            if (type in extended.has) {
                return extended.has[type](context, json);
            }
            return true;
        }
        return extended.hasDefaultExtended(context, json);
    } catch (e) {
        console.log(sprintf('hasExtended(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
    }
    return false;
};

// main method
extended.run = function(context, type, json) {
    try {
        if (type in this.make) { return this.make[type](context, json); }
        return extended.defaultExtended(context, type, json);
    } catch (e) {
        console.log(sprintf('extended(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        return 'Error in extended view construction';
    }
};

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var storage;
var summary;
var utils;
var d3;

var map = {};

var jawg = '9bHKgmlnYBVN0RILGGVn9t5mV1htebujO8fvecasKWZPb1apHmEFD9nOpWLjrYM7';

map.DrawSectionOption = {
    DRAWSTART: 2, // 10
    DRAWEND: 1, // 01
    DRAWBOTH: 3, // 11
    DRAWNEITHER: 0 // 00
};
map._should_draw_section_start = function(option) {
    return option & 2;// jshint ignore:line
};
map._should_draw_section_end = function(option) {
    return option & 1;// jshint ignore:line
};
map.STARTTEXT = 'Start';
map.ENDTEXT = 'End';
map.makeFeatures = {
    region: function(context, json) {
        if (json.shape) {
            var geoJsonShape = wkt2geojson(json.shape);
            return map._makePolygon(context, 'region', geoJsonShape, json, '#008ACA');
        }
        return [];
    },
    section: function(context, json, draw_section_option) {
        var style = {};
        if (json.display_informations && json.display_informations.color) {
            style.color = '#' + json.display_informations.color;
        }
        switch (json.type) {
        case 'street_network':
            switch (json.mode) {
            case 'bike':
                if (!json.street_informations) {
                    style = map.bikeStyle; break;
                } else if (json.street_informations && json.street_informations.length) {
                    return map._makeBikeStreetInfo(context, 'section', json)
                    .concat(map._makeStopTimesMarker(context, json, style, draw_section_option));
                } break;
            case 'taxi': style = map.taxiStyle; break;
            case 'car': style = map.carStyle; break;
            case 'carnopark': style = map.carStyle; break;
            case 'walking': style = map.walkingStyle; break;
            case 'ridesharing': style = map.ridesharingStyle; break;
            }
            break;
        case 'transfer':
            switch (json.transfer_type) {
            case 'guaranteed': style = map.carStyle; break;
            case 'extension': style = map.bikeStyle; break;
            case 'walking': style = map.walkingStyle; break;
            }
            break;
        case 'ridesharing': style = map.ridesharingStyle; break;
        case 'crow_fly': style = map.crowFlyStyle; break;
        }
        if (draw_section_option === undefined) {
            draw_section_option = map.DrawSectionOption.DRAWBOTH;
        }
        return map._makeString(context, 'section', json, style)
            .concat(map.makeFeatures.vias(context, json))
            .concat(map._makeStringViaToPt(context,'section', json, map.crowFlyStyle))
            .concat(map._makeStopTimesMarker(context, json, style, draw_section_option));
    },
    line: function(context, json) {
        return map._makeString(context, 'line', json, json);
    },
    journey: function(context, json) {
        if (! ('sections' in json)) { return []; }
        var bind = function(s, i, array) {
            var draw_section_option = map.DrawSectionOption.DRAWNEITHER;
            if ( i === 0) {
                draw_section_option |= map.DrawSectionOption.DRAWSTART;// jshint ignore:line
            }
            if ( i === (array.length -1) ) {
                draw_section_option |= map.DrawSectionOption.DRAWEND;// jshint ignore:line
            }
            return map.makeFeatures.section(context, s, draw_section_option);
        };
        return utils.flatMap(json.sections, bind);
    },
    isochrone: function(context, json) {
        if (! ('geojson' in json)) { return []; }
        var color = context.getColorFromMinDuration(json.min_duration);
        return map._makePolygon(context, 'isochrone', json.geojson, json, color)
            .concat(map._makeStopTimesMarker(context, json, {}, map.DrawSectionOption.DRAWBOTH));
    },
    heat_map: function(context, json) {
        if (! ('heat_matrix' in json)) { return []; }
        var scale = 0;
        json.heat_matrix.lines.forEach(function(lines) {
            lines.duration.forEach(function(duration) {
                if (duration !== null) {
                    scale = Math.max(duration, scale);
                }
            });
        });
        var local_map = [];
        json.heat_matrix.lines.forEach(function(lines/*, i*/) {
            lines.duration.forEach(function(duration, j) {
                var color;
                if (duration !== null) {
                    var ratio = duration / scale;
                    color = utils.getColorFromRatio(ratio);
                } else {
                    color = '#000000';
                    // for the moment, we don't want to print the null duration squares because
                    // it impacts the performances of the navigator.
                    return;
                }
                var rectangle = [
                    [json.heat_matrix.line_headers[j].cell_lat.max_lat, lines.cell_lon.max_lon],
                    [json.heat_matrix.line_headers[j].cell_lat.min_lat, lines.cell_lon.min_lon]
                ];
                local_map.push(map._makePixel(context, 'heat_map', rectangle, json, color, duration));
            });
        });
        var draw_section_option = map.DrawSectionOption.DRAWBOTH;
        return local_map.concat(map._makeStopTimesMarker(context, json, {}, draw_section_option));
    },
    address: function(context, json) {
        return map._makeMarker(context, 'address', json);
    },
    administrative_region: function(context, json) {
        return map._makeMarker(context, 'administrative_region', json);
    },
    stop_area: function(context, json) {
        return map._makeMarker(context, 'stop_area', json);
    },
    stop_point: function(context, json) {
        return map._makeMarker(context, 'stop_point', json).concat(map._makeMarkerForAccessPoint(context, json));
    },
    place: function(context, json) {
        return map._makeMarker(context, 'place', json);
    },
    pt_object: function(context, json) {
        return map.getFeatures(context, json.embedded_type, json[json.embedded_type]);
    },
    poi: function(context, json) {
        return map._makeMarker(context, 'poi', json);
    },
    free_floating: function(context, json) {
        return map._makeMarker(context, 'free_floating', json);
    },
    access_point: function(context, json) {
        var icon = map._makeAccessPointIcon(json);
        return map._makeMarker(context, 'access_point', json, null, null, icon);
    },
    connection: function(context, json) {
        return utils.flatMap([json.origin, json.destination], function(json) {
            return map._makeMarker(context, 'stop_point', json);
        });
    },
    via: function(context, json) {
        var icon = map._makeAccessPointIcon(json);
        return map._makeMarker(context, 'via', json, null, null, icon);
    },
    vias: function(context, json) {
        if (! json.vias) {
            return [];
        }
        var draw_entrance = false;
        var draw_exit = false;
        if (json.path[json.path.length - 1].via_uri){
            draw_entrance = true;
        }
        if (json.path[0].via_uri){
            draw_exit = true;
        }
        var bind = function(ap) {
            var new_ap = utils.deepClone(ap || {});
            new_ap.draw_entrance = draw_entrance;
            new_ap.draw_exit = draw_exit;
            return map.makeFeatures.via(context, new_ap);
        };
        return utils.flatMap(json.vias, bind);
    },
    vehicle_position: function(context, json) {
        if (! json.vehicle_journey_positions) { return []; }
        var bind = function(s) {
            return map.makeFeatures.vehicle_journey_position(context, s);
        };
        return utils.flatMap(json.vehicle_journey_positions, bind);
    },
    vehicle_journey_position: function(context, json) {
        return map._makeMarker(context, 'vehicle_position', json);
    },
    response: function(context, json) {
        var key = response.responseCollectionName(json);
        if (key === null) {
            return [];
        }
        var type = utils.getType(key);
        if (!(type in map.makeFeatures)) {
            return [];
        }
        var bind = function(s) {
            return map.makeFeatures[type](context, s);
        };
        return utils.flatMap(json[key].slice().reverse(), bind);
    },
    // TODO: implement when geojson_index is available
    elevations: function() {
        return [];
    }
};

map.hasMap = function(context, type, json) {
    return map.getFeatures(context, type, json).length !== 0 || map.makeElevationGraph[type] instanceof Function;
};

map.getFeatures = function(context, type, json) {
    if (! (map.makeFeatures[type] instanceof Function)) { return []; }
    if (! (json instanceof Object)) { return []; }
    try {
        return map.makeFeatures[type](context, json);
    } catch (e) {
        console.log(sprintf('map.makeFeatures[%s] thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        return [];
    }
};

map._makeTileLayers = function() {
    var copyOSM = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
    var courtesy = function(name) {
        return sprintf('%s & %s', copyOSM, name);
    };
    var makeStamenTileLayer = function(name) {
        return L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/' + name + '/{z}/{x}/{y}.png', {
            subdomains: 'abcd',
            attribution: courtesy('<a href="http://maps.stamen.com">Stamen Design</a>'),
            detectRetina: true
        });
    };
    return {
        'Bright': L.tileLayer('https://tile.jawg.io/8030075a-bdf3-4b3a-814e-e28ab5880b40/{z}/{x}/{y}.png?access-token=' + jawg, {
            attribution: courtesy('<a href="https://www.jawg.io" target="_blank">&copy; Jawg</a> - ' +
                '<a href="https://www.openstreetmap.org" target="_blank">&copy; OpenStreetMap</a>&nbsp;contributors'),
            detectRetina: true
        }),
        'Dark': L.tileLayer('https://tile.jawg.io/d3fdb780-a086-4c52-ba10-40106332bd0c/{z}/{x}/{y}.png?access-token=' + jawg, {
            attribution: courtesy('<a href="https://www.jawg.io" target="_blank">&copy; Jawg</a> - ' +
                '<a href="https://www.openstreetmap.org" target="_blank">&copy; OpenStreetMap</a>&nbsp;contributors'),
            detectRetina: true
        }),
        'HOT': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: courtesy('<a href="http://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'),
            detectRetina: true
        }),
        'Hydda': L.tileLayer('https://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png', {
            attribution: courtesy('<a href="http://openstreetmap.se/">OpenStreetMap Sweden</a>'),
            detectRetina: true
        }),
        'Mapnik': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: copyOSM,
            detectRetina: true
        }),
        'Terrain': L.tileLayer('https://tile.jawg.io/d3fdb780-a086-4c52-ba10-40106332bd0c/{z}/{x}/{y}.png?access-token=' + jawg , {
            attribution: courtesy('<a href="https://www.jawg.io" target="_blank">&copy; Jawg</a> - ' +
                '<a href="https://www.openstreetmap.org" target="_blank">&copy; OpenStreetMap</a>&nbsp;contributors'),
            detectRetina: true
        }),
        'Toner': makeStamenTileLayer('toner-lite'),
        'Watercolor': makeStamenTileLayer('watercolor'),
    };
};

map._getDefaultLayerName = function() {
    var saved = storage.getLayer();
    if (saved) { return saved; }
    return 'Bright';
};

map.createMap = function(handle) {
    var div = $('<div/>');

    // setting for default path of images used by leaflet
    L.Icon.Default.imagePath = 'lib/img/leaflet/dist/images/';
    div.addClass('leaflet');
    var m = L.map(div.get(0), {renderer: L.canvas()});
    var tileLayers = map._makeTileLayers();
    tileLayers[map._getDefaultLayerName()].addTo(m);
    L.control.layers(tileLayers).addTo(m);
    m.on('baselayerchange', storage.saveLayer);
    L.control.scale().addTo(m);
    var bounds = handle(m);

    // Cleanly destroying the map
    div.on('npg:remove', function() { m.remove(); });

    // GPS location
    var circle = L.circle([0,0], {
        radius: 100,
    });
    m.on('locationfound', function(e) {
        circle.setRadius(e.accuracy / 2)
            .setStyle({color: '#3388ff'})
            .setLatLng(e.latlng)
            .bindPopup(sprintf('%.5f;%.5f ±%dm', e.latlng.lng, e.latlng.lat, e.accuracy));
    });
    m.on('locationerror', function(e) {
        circle.setStyle({color: 'red'}).bindPopup(e.message);
    });
    m.on('unload', function() { m.stopLocate(); });
    m.locate({enableHighAccuracy: true, watch: true});

    m.on('moveend', function() { storage.saveBounds(m.getBounds()); });

    setTimeout(function() {map.bikeStyleNoCycleLane = { color: '#ed2939', dashArray: '0, 8' };
        if (bounds) { m.fitBounds(bounds); } else { m.fitWorld(); }
        circle.addTo(m); // workaround for https://github.com/Leaflet/Leaflet/issues/4978
    }, 100);

    return div;
};

map.makeElevationGraph = {};

map.makeElevationGraph.elevations = function(context, json) {
        var data = json;

        if (!data) {
            return;
        }

        var div_elevation = $('<div/>');
        div_elevation.addClass('elevation');

        var height = 100;
        var margin =  10;

        var svg = d3.select(div_elevation.get(0)).append('svg')
            .attr('class', 'elevation-svg')
            .append('g')
            .attr('transform', 'translate(20, 20)');

        svg.append('text')
            .attr('class', 'elevation-title')
            .style('font-weight', 'bold')
            .style('text-anchor', 'center')
            .attr('x', '50%')
            .attr('y', 0)
            .text('Elevation Graph');

        svg.append('text')
            .attr('class', 'elevation-label')
            .attr('x', 10)
            .attr('y', 140)
            .text('Distance from start (m)');

        svg.append('text')
            .attr('class', 'elevation-label')
            .attr('x', 10)
            .attr('y', 0)
            .text('Height (m)');

        // define the line
        // set the ranges
        var xScale = d3.scaleLinear().range([0, 1000]);
        var yScale = d3.scaleLinear().range([height, 0]);

        // Scale the range of the data
        xScale.domain(d3.extent(data, function(d) { return d.distance_from_start;}));
        yScale.domain([d3.min(data, function(d) { return d.elevation; }) / 1.2,
            d3.max(data, function(d) { return d.elevation; }) * 1.2]);
        

        var xAxis = d3.axisBottom(xScale);
        var yAxis = d3.axisLeft(yScale);

        var xGrid = xAxis.ticks(5).tickFormat('');
        var yGrid = yAxis.ticks(5).tickFormat('');

        // add the X gridlines
        svg.append('g')
            .attr('class', 'grid x')
            .attr('transform', sprintf('translate(%s, %s)', margin, height));

        // add the Y gridlines
        svg.append('g')
            .attr('class', 'grid y')
            .attr('transform', sprintf('translate(%s, 0)', margin));

        // add the valueline path.
        svg.append('path')
            .data([data])
            .attr('class', 'elevation-line')
            .attr('transform', sprintf('translate(%s, 0)', margin));

        // add the X Axis
        svg.append('g')
            .attr('class', 'axis x');

        // add the Y Axis
        svg.append('g')
            .attr('class', 'axis y');

        // to make it responsive
        var draw_elevation = function (){
            // It's impossible(?) to get the div's width, since it's not yet added to DOM...
            // the default width is set to 1600 as a good guess...
            var width = div_elevation.width() || 1600;
map.bikeStyleNoCycleLane = { color: '#ed2939', dashArray: '0, 8' };
            // Scale the range of the data
            xScale.domain(d3.extent(data, function(d) { return d.distance_from_start;}));
            xScale.range([0, width - 50]);

            xGrid.tickSize(-height);
            svg.select('.grid.x')
                .call(xGrid);

            yGrid.tickSize(-(width - 50));
            svg.select('.grid.y')
                .call(yGrid);

            svg.select('.axis.x')
                .attr('transform', sprintf('translate(%s, %s)', margin, height))
                .call(d3.axisBottom(xScale));

            svg.select('.axis.y')
                .attr('transform', sprintf('translate(%s, 0)', margin))
                .call(d3.axisLeft(yScale));

            var valueline = d3.line()
                .x(function(d) { return xScale(d.distance_from_start); })
                .y(function(d) { return yScale(d.elevation); });

            svg.selectAll('.elevation-line').attr('d', valueline);
        };

        d3.select(window).on('resize', draw_elevation);
        draw_elevation();
        return div_elevation;
};

map.getElevationGraph = function(context, type, json) {
    if (! (map.makeElevationGraph[type] instanceof Function)) { return; }
    if (! (json instanceof Object)) { return; }
    try {
        return map.makeElevationGraph[type](context, json);
    } catch (e) {
        console.log(sprintf('map.makeFeatures[%s] thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
    }
};

map.run = function(context, type, json) {
    var features = [];
    var div_elevation;
    var div = $('<div/>');

    // Draw elevations
    if ((div_elevation = map.getElevationGraph(context, type, json))) {
        div.append(div_elevation);
        // TODO: remove return once geojson_index is available
        return div;
    }

    if ((features = map.getFeatures(context, type, json)).length) {
        var div_map = map.createMap(function(m) {
            return L.featureGroup(features).addTo(m).getBounds();
        });
        div.append(div_map);
        return div;
    } else {
        var div_nomap = $('<div/>');
        div_nomap.addClass('noMap');
        div_nomap.append('No map');
        return div_nomap;
    }
};

map._makeMarkerForAccessPoint = function(context, sp) {
    if (! sp.access_points){
        return [];
    }
    var bind = function(ap) {
        ap = utils.deepClone(ap || {});
        ap.draw_entrance = ap.is_entrance;
        ap.draw_exit = ap.is_exit;
        var icon = map._makeAccessPointIcon(ap);
        var marker =  map._makeMarker(context, 'via', ap, null, null, icon);

        var style1 = utils.deepClone(map.crowFlyStyle);
        style1.color = 'white';
        style1.weight = 7;
        style1.opacity = 10;
        style1.dashArray =  '0, 12';
        var style2 = utils.deepClone(map.crowFlyStyle);
        style2.weight = 5;
        style2.opacity = 10;
        style2.dashArray =  '0, 12';

        var from = ap.coord;
        var to = sp.coord;

        return marker.concat([
            L.polyline([from, to], style1),
            L.polyline([from, to], style2)
        ]);
    };
    return utils.flatMap(sp.access_points, bind);
};

map._makeAccessPointIcon = function(json) {
    var iconUrl;
    if (json.draw_entrance && json.draw_exit) {
        iconUrl = 'img/pictos/EntranceExitMarker.png';
    } else if (json.draw_entrance) {
        iconUrl =  'img/pictos/EntranceMarker.png';
    } else if (json.draw_exit) {
        iconUrl =  'img/pictos/ExitMarker.png';
    } else if (json.is_entrance && json.is_exit) {
        iconUrl = 'img/pictos/EntranceExitMarker.png';
    } else if (json.is_entrance) {
        iconUrl = 'img/pictos/EntranceMarker.png';
    } else if (json.is_exit) {
        iconUrl = 'img/pictos/ExitMarker.png';
    } else {
        return;
    }
    return L.icon({
        iconUrl:      iconUrl,
        iconSize:     [32, 42.1],
        iconAnchor:   [16, 42.1], // point of the icon which will correspond to marker's location
    });
};

map._makeMarker = function(context, type, json, style, label, icon) {
    var lat, lon;
    var obj = json;
    switch (type){
    case 'stop_date_time':
        obj = json.stop_point;
        lat = obj.coord.lat;
        lon = obj.coord.lon;
        break;
    case 'place':
        lat = json[json.embedded_type].coord.lat;
        lon = json[json.embedded_type].coord.lon;
        break;
    case 'via':
        lat = json.access_point.coord.lat;
        lon = json.access_point.coord.lon;
        break;
    default:
        if (!json.coord){
            return [];
        }
        lat = json.coord.lat;
        lon = json.coord.lon;
    }

    var sum = summary.run(context, type, json);
    var t = type === 'place' ? json.embedded_type : type;
    var marker;
    if (! style) {
        if (icon) {
            marker = L.marker([lat, lon], {icon: icon});
        } else {
            marker = L.marker([lat, lon]);
        }
    } else {
        style = utils.deepClone(style || {});
        delete style.dashArray;
        if (! style.color) { style.color = '#000000'; }
        style.opacity = 1;
        style.fillColor = 'white';
        style.fillOpacity = 1;
        marker = L.circleMarker([lat, lon], style);
        marker.setRadius(5);
    }
    if (label) {
        marker.bindTooltip(label, {permanent: true, opacity: 1});
    }
    return [marker.bindPopup(map._makeLink(context, t, obj, sum)[0])];
};

map.bikeStyle = { color: '#a3ab3a', dashArray: '0, 8' };
map.bikeStyleNoCycleLane = { color: '#cd6155', dashArray: '0, 8' };
map.bikeStyleSharedCycleWay = { color: '#e59866', dashArray: '0, 8' };
map.bikeStyleDedicatedCycleWay = { color: '#82e0aa', dashArray: '0, 8' };
map.bikeStyleSeparatedCycleWay = { color: '#239b56', dashArray: '0, 8' };
map.carStyle = { color: '#c9731d', dashArray: '0, 8' };
map.taxiStyle = { color: '#297e52', dashArray: '0, 8' };
map.walkingStyle = { color: '#298bbc', dashArray: '0, 8' };
map.ridesharingStyle = { color: '#6e3ea8', dashArray: '0, 8' };
map.crowFlyStyle = { color: '#6e3ea8', dashArray: '0, 8' };

map._getCoordFromPlace = function(place) {
    if (place && place[place.embedded_type] && place[place.embedded_type].coord) {
        return place[place.embedded_type].coord;
    }
    return null;
};

map._makeStringViaToPt = function(context, type, json, style) {
    if (! json.vias || json.vias.length === 0) {
        return [];
    }
    var from;
    var to;

    // At the moment, we have only one via in PathItem
    if (json.path[json.path.length - 1].via_uri){
        from = json.vias[0].access_point.coord;
        to = map._getCoordFromPlace(json.to);
    }
    if (json.path[0].via_uri){
        from = map._getCoordFromPlace(json.from);
        to = json.vias[0].access_point.coord;
    }

    var style1 = utils.deepClone(style);
    style1.color = 'white';
    style1.weight = 7;
    style1.opacity = 1;
    style1.dashArray =  '0, 10';
    var style2 = utils.deepClone(style);
    style2.weight = 5;
    style2.opacity = 1;
    style2.dashArray =  '0, 10';

    var sum =  summary.run(context, type, json);

    return [
        L.polyline([from, to], style1),
        L.polyline([from, to], style2).bindPopup(sum)
    ];
};

map._makeSubGeojson = function(geojson, start, end) {
    var res = utils.deepClone(geojson);
    res.coordinates = geojson.coordinates.slice(start, end+1);
    return res;
};

map._pushCycleLaneStyle = function(context, type, json, sub_geojson, street_info, cycle_lane_type_styles, style, line) {
    var sum = summary.run(context, type, json);
    if (street_info.cycle_path_type in cycle_lane_type_styles) {
        sum.append(' (', street_info.cycle_path_type, ')');
        cycle_lane_type_styles[street_info.cycle_path_type].weight = 5;
        cycle_lane_type_styles[street_info.cycle_path_type].opacity = 1;
        line.push(
            L.geoJson(sub_geojson, { style: style }),
            L.geoJson(sub_geojson, { style: cycle_lane_type_styles[street_info.cycle_path_type] }).bindPopup(sum)
        );
    }
};

map._makeBikeStreetInfo = function(context, type, json) {
    var cycleLaneTypeStyles = {
        'no_cycle_lane': map.bikeStyleNoCycleLane,
        'shared_cycle_way': map.bikeStyleSharedCycleWay,
        'separated_cycle_way': map.bikeStyleSeparatedCycleWay,
        'dedicated_cycle_way': map.bikeStyleDedicatedCycleWay
    };

    var styleWhite = { color: 'white', dashArray: '0, 8', weight: 7, opacity: 1 };

    var line = [];
    var subGeojson;
    var newJson;

    if (json.street_informations &&
        json.street_informations.length &&
        json.geojson &&
        json.geojson.coordinates !== undefined &&
        json.geojson.coordinates.length) {
        var fromOffset = json.street_informations[0].geojson_offset;

        for (var idx = 1; idx < json.street_informations.length; idx++) {
            var streetInfo = json.street_informations[idx - 1];
            var offset = json.street_informations[idx].geojson_offset;

            subGeojson = map._makeSubGeojson(json.geojson, fromOffset, offset);
            newJson = utils.deepClone(json);
            newJson.streetInfo = streetInfo;
            map._pushCycleLaneStyle(context, type, newJson, subGeojson, streetInfo, cycleLaneTypeStyles, styleWhite, line);
            fromOffset = offset;
        }

        subGeojson = map._makeSubGeojson(json.geojson, fromOffset, json.geojson.coordinates.length);
        newJson = utils.deepClone(json);
        newJson.streetInfo = json.street_informations[json.street_informations.length-1];
        map._pushCycleLaneStyle(context, type, newJson, subGeojson, newJson.streetInfo, cycleLaneTypeStyles, styleWhite, line);
    }
    return line;
};

map._makeString = function(context, type, json, style) {
    style = utils.deepClone(style || {});
    if (! style.color) { style.color = '#000000'; }
    if (style.color.match(/^[0-9A-Fa-f]{6}$/)) { style.color = '#' + style.color; }
    var sum = summary.run(context, type, json);
    var from = map._getCoordFromPlace(json.from);
    var to = map._getCoordFromPlace(json.to);

    var style1 = utils.deepClone(style);
    style1.color = 'white';
    style1.weight = 7;
    style1.opacity = 1;
    var style2 = utils.deepClone(style);
    style2.weight = 5;
    style2.opacity = 1;

    if (json.geojson && json.geojson.coordinates.length) {
        return [
            L.geoJson(json.geojson, { style: style1 }),
            L.geoJson(json.geojson, { style: style2 }).bindPopup(sum)
        ];
    } else if (from && to) {
        return [
            L.polyline([from, to], style1),
            L.polyline([from, to], style2).bindPopup(sum)
        ];
    } else {
        return [];
    }
};

map._makeStopTimesMarker = function(context, json, style, draw_section_option) {
    var stopTimes = json.stop_date_times;
    var markers = [];
    if (stopTimes) {
        // when section is PT
        stopTimes.forEach(function(st, i) {
            var label = null;
            if (i === 0 &&
                map._should_draw_section_start(draw_section_option)) {
                label = map.STARTTEXT;
            }else if (i === (stopTimes.length -1 ) &&
                      map._should_draw_section_end(draw_section_option)) {
                label = map.ENDTEXT;
            }
            markers = markers.concat(map._makeMarker(context, 'stop_date_time', st, style, label));
        });
    } else {
        // when section is Walking
        var from = json.from;
        var to = json.to;
        var label_from = null;
        var label_to = null;
        if (from && map._should_draw_section_start(draw_section_option)) {
            label_from = map.STARTTEXT;
            markers.push(map._makeMarker(context, 'place', from, style, label_from)[0]);
        }
        if (to && map._should_draw_section_end(draw_section_option)) {
            label_to = map.ENDTEXT;
            markers.push(map._makeMarker(context, 'place', to, style, label_to)[0]);
        }
    }
    return markers;
};
map._makePolygon = function(context, type, geoJsonCoords, json, color) {
    var sum = summary.run(context, type, json);
    // TODO use link when navitia has debugged the ticket NAVITIAII-2133
    var link = map._makeLink(context, type, json, sum)[0];
    return [
        L.geoJson(geoJsonCoords, {
            color:  '#555555',
            opacity: 1,
            weight: 0.5,
            fillColor: color,
            fillOpacity: 0.25
        }).bindPopup(link)
    ];
};
map._makeLink = function(context, type, obj, name) {
    return context.makeLink(type, obj, name);
};
map._makePixel = function(context, type, PolygonCoords, json, color, duration) {
    var sum = 'not accessible';
    if (duration !== null) {
        sum = sprintf('duration: %s', utils.durationToString(duration));
    }
    return L.rectangle(PolygonCoords, {
        smoothFactor: 0,
        color:  '#555555',
        opacity: 0,
        weight: 0,
        fillColor: color,
        fillOpacity: 0.25
    }).bindPopup(sum);
};

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

var pictos = {};

pictos.makePtPicto = function(json) {
    if ($.isArray(json)) {
        var res = $('<span/>');
        json.forEach(function(elt) {
            res.append(pictos.makePtPicto(elt));
        });
        return res;
    }

    if (!(json instanceof Object) || !('id' in json)) {
        return $('<span/>');
    }
    var img = 'Unknown';
    switch (json.id) {
    case 'physical_mode:Air': img = 'Air'; break;
    case 'physical_mode:Bike': img = 'Bike'; break;
    case 'physical_mode:BikeSharingService': img = 'BikeSharingService'; break;
    case 'physical_mode:Car': img = 'Car'; break;
    case 'physical_mode:Coach': img = 'Coach'; break;
    case 'physical_mode:Metro': img = 'Metro'; break;
    case 'physical_mode:Taxi': img = 'Taxi'; break;
    case 'physical_mode:Tramway': img = 'Tramway'; break;
    case 'physical_mode:Walking': img = 'Walking'; break;
    case 'physical_mode:CheckIn': img = 'CheckIn'; break;
    case 'physical_mode:CheckOut': img = 'CheckOut'; break;
    case 'physical_mode:Shuttle': img = 'Shuttle'; break;

    case 'physical_mode:Funicular':
    case 'physical_mode:SuspendedCableCar':
        img = 'Funicular'; break;

    case 'physical_mode:Bus':
    case 'physical_mode:BusRapidTransit':
    case 'physical_mode:Trolleybus':
        img = 'Bus'; break;

    case 'physical_mode:RapidTransit':
    case 'physical_mode:LocalTrain':
    case 'physical_mode:LongDistanceTrain':
    case 'physical_mode:Train':
    case 'physical_mode:RailShuttle':
        img = 'Train'; break;

    case 'physical_mode:Boat':
    case 'physical_mode:Ferry':
        img = 'Boat'; break;

    default:
        break;
    }

    return pictos.makeImg(img, json.name);
};

pictos.makeImg = function(img, name) {
    return pictos.makeImgFromUrl(sprintf('img/pictos/%s.svg', img), name);
};

pictos.makeImgFromUrl = function(img, name) {
    var tag = $('<img/>')
        .addClass('picto')
        .attr('src', img);
    if (name) { tag.attr('alt', name); tag.attr('title', name); }
    return tag;
};

pictos.makeSnPicto = function(mode) {
    var img = 'Unknown';
    if (mode === 'walking') {
        img = 'Walking';
    } else if (mode === 'bike') {
        img = 'Bike';
    } else if (mode.indexOf('bss') === 0) {
        img = 'BikeSharingService';
    } else if (mode === 'car' || mode === 'carnopark' || mode === 'park' || mode === 'leave_parking') {
        img = 'Car';
    } else if (mode === 'ridesharing') {
        img = 'RideSharing';
    } else if (mode === 'taxi') {
        img = 'Taxi';
    } else if (mode === 'entrance') {
        img = 'Entrance';
    } else if (mode === 'exit') {
        img = 'Exit';
    }
    return pictos.makeImg(img, mode);
};

pictos.makeEquipmentPicto = function(equipment) {
    var img = 'Unknown';
    switch (equipment) {
    case 'has_wheelchair_accessibility':
    case 'has_wheelchair_boarding':
        img = 'Wheelchair'; break;
    case 'has_bike_accepted':
    case 'has_bike_depot':
        img = 'BikeAccepted'; break;
    case 'has_air_conditioned': img = 'AirConditioning'; break;
    case 'has_visual_announcement': img = 'HearingImpairment'; break;
    case 'has_audible_announcement': img = 'VisualImpairment'; break;
    case 'has_appropriate_escort': img = ''; break;
    case 'has_appropriate_signage': img = 'MentalDisorder'; break;
    case 'has_school_vehicle': img = 'SchoolBus'; break;
    case 'has_elevator': img = 'Elevator'; break;
    case 'has_escalator': img = 'Escalator'; break;
    case 'has_sheltered': img = 'Shelter'; break;
    }
    return pictos.makeImg(img, equipment);
};

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var storage;
var autocomplete;
var utils;

var request = {};

request.setSaveTokenButtonStatus = function() {
    var api = $('#api input.api').val();
    var token = $('#token input.token').val();
    $('button.save').prop('disabled', storage.getToken(api) === token);
};

request.updateAddPathAC = function(val){
    var input = $(val).prev();
    if (! input.hasClass('path')) {
        return;
    }
    if (! $('input path').length) {
        // No more path inputs, we should update autocomplete of add
        autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    }
};

request.getFocusedElemValue = function(elemToTest, focusedElem, noEncoding) {
    var value = $(elemToTest).is('input') ? elemToTest.value : $(elemToTest).text();
    if (! noEncoding) { value = encodeURIComponent(value); }
    if (focusedElem === elemToTest) {
        return sprintf('<span class="focusedParam">%s</span>', value);
    } else {
        return value;
    }
};

request.urlElements = function(focusedElem) {
    var api = request.getFocusedElemValue($('#api input.api')[0], focusedElem, true);
    if (api.slice(-1) === '/') { api = api.slice(0, -1); }

    var path = '';
    $('#path .key, #path input.value').each(function(){
        path += '/' + request.getFocusedElemValue(this, focusedElem);
    });
    var feature = request.getFocusedElemValue($('#featureInput')[0], focusedElem);

    var parameters = '?';
    $('#parameters .key, #parameters input.value').each(function(){
        parameters += request.getFocusedElemValue(this, focusedElem);
        if ($(this).hasClass('key')) {
            parameters += '=';
        }
        if ($(this).hasClass('value')) {
            parameters += '&';
        }
    });
    return {'api': api, 'path': path, 'parameters': parameters, 'feature': feature};
};

request.finalUrl = function(focusedElem) {
    var elements = request.urlElements(focusedElem);
    if (focusedElem === undefined) {
        // called without arg, we want pure text
        return elements.api + elements.path + '/' + elements.feature + elements.parameters;
    } else {
        // with arg, we want a rendering thing
        return sprintf('<span class="api">%s</span>' +
                       '<span class="path">%s</span>' +
                       '<span class="feature">/%s</span>' +
                       '<span class="parameters">%s</span>',
                       elements.api, elements.path, elements.feature, elements.parameters);
    }
};

request.updateUrl = function(focusedElem) {
    var link = request.finalUrl();
    var text = request.finalUrl(focusedElem);
    $('#requestUrl').html($('<a/>').attr('href', link).html(text));
};

request.makeDeleteButton = function() {
    return $('<button/>')
        .html('<img src="img/delete.svg">')
        .click(function() {
            $(this).closest('.toDelete').remove();
            request.updateAddPathAC(this);
            request.updateUrl(this);
        });
};

request.makeTemplatePath = function(val, input) {
    var templateFilled = false;
    var isTemplateFilled = function() {
        var curVal = input.val();
        if (! templateFilled && curVal !== val && curVal !== '') {
            input.closest('.inputDiv').removeClass('templateInput');
            templateFilled = true;
        }
        return templateFilled;
    };
    input.closest('.inputDiv').addClass('templateInput');
    input.focus(function() {
        if (! isTemplateFilled()) { this.value = ''; }
    }).blur(function() {
        if (! isTemplateFilled()) { this.value = val; }
    });
};

request.makeKeyValue = function(key, val, cls) {
    var res = $('<div/>')
        .addClass('inputDiv')
        .addClass('toDelete')
        .append(' ');

    res.append($('<span/>').addClass('key').text(key));

    var valueElt = $('<input/>')
        .attr('type', 'text')
        .attr('autocomplete', 'off')
        .attr('placeholder', 'type your value here')
        .addClass('value')
        .addClass(cls)
        .focus(function() { this.select(); })
        .val(val)
        .appendTo(res);
    res.append($('<span class="tooltips">'));
    res.append(request.makeDeleteButton());

    autocomplete.valueAutoComplete(valueElt, key);
    valueElt.on('input', function() { request.updateUrl(this); });
    valueElt.focus(function() { request.updateUrl(this); });
    if (utils.isTemplate(val)) { request.makeTemplatePath(val, valueElt); }

    return res;
};

request.insertPathElt = function() {
    var key = $('#addPathInput').val();
    $('#addPathElt').before(request.makeKeyValue(key, '', 'path'));
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    $('#addPathInput').val('').change();
    $('#addPathElt').prev().find('input').first().focus();
};

request.insertParam = function() {
    var key = $('#addParamInput').val();
    $('#addParam').before(request.makeKeyValue(key, '', 'parameters'));
    $('#addParamInput').val('').change();
    $('#addParam').prev().find('input').first().focus();
};

request.submit = function() {
    var url = '?request=' + encodeURIComponent(request.finalUrl());
    var token = $('#token input.token').val();
    if (storage.getToken($('#api input.api').val()) !== token) {
        url += '&token=' + encodeURIComponent(token);
    }
    window.location = url;
};

request.getCoverage = function() {
    var prevIsCoverage = false;
    var coverage = null;
    $('#path .key, #path input.value').each(function() {
        if (prevIsCoverage) {
            coverage = $(this).val();
        }
        prevIsCoverage = $(this).text() === 'coverage';
    });
    return coverage;
};

request.parseUrl = function() {
    var search = new URI(window.location).search(true);
    var req = search.request;
    if (req === undefined) { return null; }

    var req_uri = new URI(req);
    var api = req_uri.origin();
    var paths = req_uri.path().split('/');
    paths = paths.length === 1 ? [] : paths.slice(1);
    var api_path = [];

    var vxxFound = false;
    paths.forEach(function(r) {
        if (vxxFound) {
            api_path.push(decodeURIComponent(r));
        } else {
            api += '/' + decodeURIComponent(r);
            vxxFound = /^v\d+$/.test(r);
        }
    });
    if (! vxxFound) {
        api = req_uri.origin();
        api_path = paths.map(decodeURIComponent);
        utils.notifyWarn('Version not found in the URL. Maybe you forgot "/v1" at the end of the API?');
    }

    var params = req_uri.search(true);

    var token = search.token;

    if (token === undefined) {
        if (req_uri.username()) {
            token = req_uri.username();
            api = new URI(api).username('').toString();
        } else { token = storage.getToken(api); }
    }

    return {
        token: token,
        request: req,
        api: api,
        path: api_path,
        query: params === undefined ? {} : params
    };
};

request.setAutocomplete = function(){
    autocomplete.addKeyAutocomplete($('#featureInput'), 'features');
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
    autocomplete.apiAutocomplete();
};

request.keyboardSubmit = function() {
    $(document).keydown(function(event) {
        // control+enter, or option+enter on OS X
        if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            request.submit();
        }
    });
};

request.manage = function() {
    // save token
    request.setSaveTokenButtonStatus();
    $('input.token')
        .change(request.setSaveTokenButtonStatus)
        .on('input', request.setSaveTokenButtonStatus);

    // hidden token management
    $('input.token').focusin(function() { $(this).attr('type', 'text'); })
        .focusout(function() { $(this).attr('type', 'password'); });

    // Manage add input/button
    $('button.add').prop('disabled', true);
    $('.addInput').on('input change', function() {
        $(this).parent().find('button.add').prop('disabled', this.value.length === 0);
    });
    $('.addInput').keyup(function(event) {
        if (event.keyCode === 13) {
            $(this).parent().find('button.add').click();
        }
    });

    $('#request input').focus(function() { this.select(); });

    var req = request.parseUrl();

    if (req === null) {
        request.setAutocomplete();
        return;
    }

    if (req.token === undefined) { req.token = ''; }
    $('#token input.token').attr('value', req.token);
    $('#api input.api').attr('value', req.api);
    request.setSaveTokenButtonStatus();

    var prevPathElt = null;
    req.path.forEach(function(r) {
        if (prevPathElt === null) {
            prevPathElt = r;
        } else {
            $('#addPathElt').before(request.makeKeyValue(prevPathElt, r, 'path'));
            prevPathElt = null;
        }
    });
    if (prevPathElt !== null) {
        $('#featureInput').val(prevPathElt);
    }

    var addParam = $('#addParam');
    for (var key in req.query) {
        if (! req.query.hasOwnProperty(key)) { continue; }
        var value = req.query[key];
        // a list of params, ex.: forbidded_uris[]
        if (Array.isArray(value)) {
            value.forEach(function(v){
                addParam.before(request.makeKeyValue(decodeURIComponent(key), decodeURIComponent(v), 'parameters'));
            });
        } else {
            addParam.before(request.makeKeyValue(decodeURIComponent(key), decodeURIComponent(value), 'parameters'));
        }
    }
    request.setAutocomplete();
    request.updateUrl(null);
};

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var summary;
var extended;
var map;
var storage;
var autocomplete;
var utils;
var request;

var response = {};


// Handle scroll-to-top button
function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    document.getElementById('goTopButton').style.display = 'block';
  } else {
    document.getElementById('goTopButton').style.display = 'none';
  }
}

window.onscroll = function() {scrollFunction();};

response.topFunction = function() {
  document.body.scrollTop = 0; // For Safari
  document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
};


response.setStatus = function(message, status, start_time) {
    var res = $('<span/>').text('Status: ').append(message);
    res.append(utils.htmlEncode(sprintf(' (%s)', status)));
    if (typeof start_time === 'number') {
        var duration = new Date().getTime() - start_time;
        res.append(sprintf(', duration of the request: %dms', duration));
    }
    $('#status').html(res);
};

response.responseCollectionName = function(json) {
    if (! (json instanceof Object)) { return null; }
    var key = null;
    var notCollectionKeys = ['disruptions', 'links', 'feed_publishers', 'exceptions', 'notes', 'warnings', 'tickets', 'terminus'];
    for (var k in json) {
        if ($.isArray(json[k]) &&
            $.inArray(k, notCollectionKeys) === -1) {
            key = k;
        }
    }
    // disruptions may be an object list only if there is no other object list
    if (key === null && 'disruptions' in json) {
        key = 'disruptions';
    }
    return key;
};

response.makeObjectButton = function(name, handle) {
    // TODO call handle on toggle
    return $('<label>')
        .addClass('objectButton')
        .append($('<input type="checkbox">').change(handle))
        .append($('<span>').html(name));
};

response.makeObjectButtonHandle = function(selector, renderHandle) {
    return function() {
        var div = $(this).closest('div.object').children('div.data').children(selector);
        if ($(this).is(':checked')) {
            div.hide();
            div.html(renderHandle());
            div.slideDown(600);
            if (! $(this).hasClass('noAnimation')) {
                $('html, body').animate({ scrollTop: div.offset().top }, 600);
            }
        } else {
            div.slideUp(600, function() {
                div.children().trigger('npg:remove');
                div.empty();
            });
        }
    };
};

response.render = function(context, json, type, key, idx) {
    var name = key;
    if (typeof idx === 'number') { name += sprintf('[%s]', idx); }
    name = context.makeLink(key, json, name);

    var head = $('<div class="head">');
    head.append($('<div class="name">').html(name));
    head.append($('<div class="summary">').html(summary.run(context, type, json)));
    var button = $('<div class="button">');
    if (extended.hasExtended(context, type, json)) {
        button.append(
            response.makeObjectButton(
                'Ext',
                response.makeObjectButtonHandle('div.extended', function() {
                    return extended.run(context, type, json);
                })
            )
        );
    }
    if (map.hasMap(context, type, json)) {
        button.append(
            response.makeObjectButton(
                'Map',
                response.makeObjectButtonHandle('div.map', function() {
                    return map.run(context, type, json);
                })
            )
        );
    }
    button.append(
        response.makeObjectButton(
            '{ }',
            response.makeObjectButtonHandle('div.code', function() {
                return renderjson(json);
            })
        )
    );
    head.append(button);

    var data = $('<div class="data">')
        .append($('<div class="extended">').hide())
        .append($('<div class="map">').hide())
        .append($('<div class="code">').hide());

    var result = $('<div class="object">');
    result.append(head);
    result.append(data);
    return result;
};

response.Context = function(data) {
    // the token, used to create links
    var token = URI(window.location).search(true).token;

    // the regex corresponding to the thing that should be replacced
    // in a templated link
    var templateRegex = /\{.*\.id\}/;

    // the link map: type -> template
    this.links = {};
    if (data instanceof Object && 'links' in data && $.isArray(data.links)) {
        var self = this;
        data.links.forEach(function(link) {
            if (! link.templated) { return; }
            if (link.type === 'related') { return; }
            if (! link.href.match(templateRegex)) { return; }
            self.links[utils.getType(link.type)] = link.href;
        });
    }

    this.makeHref = function(href) {
        var res = sprintf('?request=%s', encodeURIComponent(href));
        if (token) {
            res += sprintf('&token=%s', encodeURIComponent(token));
        }
        return res;
    };

    this.makeLink = function(k, obj, name) {
        var key = utils.getType(k);
        if (typeof name === 'string') { name = utils.htmlEncode(name); }
        if (! (key in this.links) || ! ('id' in obj)) {
            return $('<span/>').html(name);
        }
        var href = this.links[key].replace(templateRegex, obj.id);
        return $('<a>').attr('href', this.makeHref(href)).html(name);
    };

    var minDurationColor = {};
    if (data instanceof Object && 'isochrones' in data && $.isArray(data.isochrones)) {
        var min_duration = data.isochrones.map(function(isochrone) { return isochrone.min_duration; });
        var max_isochrone = data.isochrones.length;
        var scale = max_isochrone > 1 ? max_isochrone - 1 : 1;
        for (var i = 0; i < max_isochrone; i ++) {
            var ratio = i / scale;
            minDurationColor[min_duration[i]] = utils.computeColorFromRatio(ratio);
        }
    }
    this.getColorFromMinDuration = function(minDuration, alpha) {
        var color = minDurationColor[minDuration] || {red: 0, green: 0, blue: 0};
        return utils.toCssColor(color, alpha);
    };

    this.followInternalLink = function(link) {
        if (link.internal !== true) { return null; }
        if (!(link.rel in data)) { return null; }
        var index = data[link.rel].findIndex(function(elt) { return elt.id === link.id; });
        if (index === -1) { return null; }
        return {
            path: sprintf('response.%s[%i]', link.rel, index),
            obj: data[link.rel][index],
        };
    };
};

response.manageFile = function() {
    function readSingleFile(event) {
        event.preventDefault();
        event.stopPropagation();
        var files = event.target.files || event.originalEvent.dataTransfer.files;
        if (!files || !files[0]) { return; }
        var file = files[0];
        var reader = new FileReader();
        reader.onload = function(event) {
            try {
                var data = JSON.parse(event.target.result);
                $('#status').text(sprintf('Status: file "%s" loaded', file.name));
                $('#data').html(response.render(new response.Context(data), data, 'response', 'response'));
                $('#data input').first().click();
            } catch (e) {
                $('#status').text(
                    sprintf('Status: error while loading file "%s": %s', file.name, e)
                );
            }
        };
        reader.readAsText(file);
        $('#file-input').val(null);// be sure to have next change
    }

    $('#file-input').change(readSingleFile);
    $(document)
        .on('dragover', false)
        .on('dragleave', false)
        .on('drop', readSingleFile);
};

response.manageUrl = function() {
    var req = request.parseUrl();
    if (req === null) {
        $('#status').html('Status: no request');
        return;
    }
    var start_time = new Date().getTime();
    $.ajax({
        headers: utils.manageToken(req.token),
        url: req.request,
        dataType: 'json',
    }).then(
        function(data, status, xhr) {
            response.setStatus(xhr.statusText, xhr.status, start_time);
            $('#data').html(response.render(new response.Context(data), data, 'response', 'response'));
            $('#data input').first().addClass('noAnimation');
            $('#data input').first().click();
            $('html, body').animate({ scrollTop: $('#response').offset().top }, 600);
            if (! storage.getToken(req.api)) {
                storage.saveToken(req.api, req.token);
            }
            // update the drop list of autocompletion for API
            autocomplete.apiAutocomplete();
        },
        function(xhr, status, error) {
            response.setStatus(utils.errorMessage(req.request, xhr, status, error),
                               xhr.status,
                               start_time);
            $('#data').html(response.render(new response.Context(xhr.responseJSON), xhr.responseJSON, 'response', 'response'));
            $('#data input').last().click();
            utils.notifyOnError('Response', req.request, xhr, status, error);
        }
    );
};

// renderjson config
$(document).ready(function() {
    renderjson.set_show_to_level(1);
    renderjson.set_max_string_length(60);
    renderjson.set_sort_objects(true);
});

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var request;

var storage = {};

storage._storagePrefix = 'navitia-playground.';
storage._apiStoragePrefix = storage._storagePrefix + 'api.';
storage._layerStorageKey = storage._storagePrefix + 'layer';
storage._boundsStorageKey = storage._storagePrefix + 'bounds';

storage._localStorageAvailable = function() {
    try {
	var x = '__storage_test__';
	window.localStorage.setItem(x, x);
	window.localStorage.removeItem(x);
	return true;
    }
    catch(e) {
	return false;
    }
};

storage.getApis = function() {
    if (! storage._localStorageAvailable()) { return []; }
    var apis = [];
    for (var elt in window.localStorage) {
        if (elt.indexOf(storage._apiStoragePrefix) === 0 ) {
            apis.push(elt.slice(storage._apiStoragePrefix.length));
        }
    }
    return apis;
};

storage.saveTokenFromRequest = function() {
    var api = $('input.api').val();
    var token = $('input.token').val();
    storage.saveToken(api, token);
};

storage.saveToken = function(api, token) {
    if (! storage._localStorageAvailable()) { return; }
    var key = storage._apiStoragePrefix + api;
    window.localStorage.setItem(key, token);
    request.setSaveTokenButtonStatus();
};

storage.getToken = function(api) {
    if (! storage._localStorageAvailable()) { return; }
    return window.localStorage.getItem(storage._apiStoragePrefix + api);
};

storage.saveLayer = function(data) {
    if (! storage._localStorageAvailable()) { return; }
    window.localStorage.setItem(storage._layerStorageKey, data.name);
};

storage.getLayer = function() {
    if (! storage._localStorageAvailable()) { return null; }
    return window.localStorage.getItem(storage._layerStorageKey);
};

storage.saveBounds = function(bounds) {
    if (! storage._localStorageAvailable()) { return; }
    var data = [
        [bounds.getSouth(), bounds.getWest()],
        [bounds.getNorth(), bounds.getEast()]
    ];
    window.localStorage.setItem(storage._boundsStorageKey, JSON.stringify(data));
};

storage.getBounds = function() {
    if (! storage._localStorageAvailable()) { return null; }
    return JSON.parse(window.localStorage.getItem(storage._boundsStorageKey));
};

// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var pictos;
var utils;

var summary = {};

summary.make = {};

summary.make.response = function(context, json) {
    if (! json) {
        return 'Error: response is not JSon';
    }
    if ('message' in json) {
        return sprintf('Message: %s', json.message);
    }
    if ('error' in json && json.error && 'message' in json.error) {
        return sprintf('Error: %s', json.error.message);
    }
    var result = '';
    var key = response.responseCollectionName(json);
    if (key) {
        result = result + sprintf(' %s %s ', json[key].length, key);
    }
    if ('pagination' in json) {
        var p = json.pagination;
        var first_number = p.start_page * p.items_per_page + 1;
        result = result + sprintf('(%s-%s of %s results)',
            first_number,
            first_number + p.items_on_page - 1,
            p.total_result);
    }
    return result;
};

summary.make.journey = function(context, json) {
    var res = $('<span>').append(summary.formatTime(json.departure_date_time));
    function add(s) {
        res.append(' > ');
        $('<span/>').addClass('mode-and-code').append(s).appendTo(res);
    }

    if ('sections' in json) {
        var first_section_mode = null;
        var last_section_mode = null;
        json.sections.forEach(function(s) {
            switch (s.type) {
            case 'public_transport':
            case 'on_demand_transport':
                if (! first_section_mode) {
                    first_section_mode = last_section_mode;
                }
                last_section_mode = null;
                break;
            case 'crow_fly':
            case 'street_network':
                if (s.duration) {
                    switch (s.mode) {
                    case 'bike': last_section_mode = 'bike'; break;
                    case 'car': last_section_mode = 'car'; break;
                    case 'carnopark': last_section_mode = 'car'; break;
                    case 'ridesharing': last_section_mode = 'ridesharing'; break;
                    case 'taxi': last_section_mode = 'taxi'; break;
                    case 'walking':
                        if (! last_section_mode) { last_section_mode = 'walking'; }
                        break;
                    }
                }
                break;
            case 'bss_rent':
            case 'bss_put_back':
                last_section_mode = 'bss';
                break;
            }
        });

        if (first_section_mode) {
            add(pictos.makeSnPicto(first_section_mode));
        }
        var stayIn = false;
        json.sections.forEach(function(s) {
            if (s.type === 'ridesharing') {
                var ridesharing = $('<span>').append(pictos.makeSnPicto('ridesharing'));
                var infos = s.ridesharing_informations;
                if (infos.driver && infos.driver.image) {
                    ridesharing.append(pictos.makeImgFromUrl(infos.driver.image, infos.driver.alias));
                }
                add(ridesharing);
                return;
            }
            if (s.type === 'transfer' && s.transfer_type === 'stay_in') {
                stayIn = true;
            }
            if ($.inArray(s.type, ['public_transport', 'on_demand_transport']) === -1) { return; }
            if (stayIn) {
                res.append('&thinsp;').append(summary.makeLineCode(s.display_informations));
                stayIn = false;
            } else {
                add(summary.makePhysicalModesFromSection(s)
                    .append(summary.makeLineCode(s.display_informations)));
            }
        });
        if (last_section_mode) {
            add(pictos.makeSnPicto(last_section_mode));
        }
    } else {
        // isochron
        add(summary.run(context, 'place', json.from));
        add(sprintf('%s transfer(s)', json.nb_transfers));
        add(summary.run(context, 'place', json.to));
    }
    add(summary.formatTime(json.arrival_date_time));

    if ('durations' in json) {
        if (json.durations.total) {
            $('<span/>')
                .addClass('section-additional-block')
                .append($('<img>').addClass('picto').attr('src', 'img/duration.svg'))
                .append(' ' + utils.durationToString(json.durations.total))
                .appendTo(res);
        }
        ['walking', 'bike', 'car', 'ridesharing'].forEach(function(mode) {
            if (!json.durations[mode]) { return; }
            $('<span/>')
                .addClass('section-additional-block')
                .append(pictos.makeSnPicto(mode))
                .append(utils.durationToString(json.durations[mode]))
                .appendTo(res);
        });
    }

    if (json.status) {
        $('<span/>')
            .addClass('section-additional-block')
            .append('status: ' + utils.htmlEncode(json.status))
            .appendTo(res);
    }

    return res;
};

summary.make.isochrone = function(context, json) {
    var res = $('<span>');
    if ('from' in json) {
      res.append(sprintf('from %s, ', utils.htmlEncode(json.from.name)));
    }
    if ('to' in json) {
      res.append(sprintf('to %s, ', utils.htmlEncode(json.to.name)));
    }
    if ('min_duration' in json && 'max_duration' in json) {
        $('<span/>')
            .addClass('with-bg-color')
            .css('background-color', context.getColorFromMinDuration(json.min_duration, 0.25))
            .text(sprintf('duration: [%s, %s]',
                          utils.durationToString(json.min_duration),
                          utils.durationToString(json.max_duration)))
            .appendTo(res);
    } else {
        res.text('no summary');
    }
    return res;
};

summary.make.heat_map = function(context, json) {
    var res = $('<span>');
    if ('from' in json) {
      res.append(sprintf('from %s, ', utils.htmlEncode(json.from.name)));
    } else if ('to' in json) {
      res.append(sprintf('to %s, ', utils.htmlEncode(json.to.name)));
    } else {
        res.text('no summary');
    }
    return res;
};

summary.make.links = function(context, json) {
    var res = $('<span>');
    function makeName(link) {
        var name = link.type;
        if (link.rel) { name = link.rel; }
        var internal = context.followInternalLink(link);
        if (internal) { name = internal.path; }
        if (link.templated) { return sprintf('{%s}', name); }
        return name;
    }
    if ($.isArray(json)) {
        json.forEach(function(link) {
            res.append(' ');
            if (link.id) {
                context.makeLink(link.type, link, makeName(link)).appendTo(res);
            } else if (link.href) {
                $('<a>')
                    .attr('href', context.makeHref(link.href))
                    .text(makeName(link))
                    .appendTo(res);
            } else {
                res.append(makeName(link));
            }
        });
    } else {
        res.append('Links is not an array!');
    }
    return res;
};

summary.make.codes = function(context, json) {
    var text = json.map(function(code) {
        return sprintf('%s: %s', code.type, code.value);
    }).join(', ');
    return $('<span>').text(text);
};

summary.make.vias = function(context, json) {
    var res = $('<span>');
    res.append(sprintf('%s via(s)  ', json.vias.length));
    res.append(pictos.makeSnPicto('entrance'));
    return res;
};

summary.make.warning = function(context, json) {
    return $('<span>').text(json.message);
};

summary.make.pt_object = summary.make.place = function(context, json) {
    var res = $('<span>')
        .text(json.embedded_type)
        .append(': ')
        .append(summary.run(context, json.embedded_type, json[json.embedded_type]));
    if ('distance' in json) {
        res.append(sprintf(' at %dm', json.distance));
    }
    return res;
};

summary.make.table = function(context, json) {
    return $('<span>').text(sprintf('%d vehicle journeys, %d stop points',
                                    json.headers.length,
                                    json.rows.length));
};

summary.make.section = function(context, section) {
    var res = $('<span>');
    var pt = false;

    switch (section.type) {
    case 'street_network': res.append(pictos.makeSnPicto(section.mode)); break;
    case 'ridesharing': res.append(pictos.makeSnPicto('ridesharing')); break;
    case 'bss_rent':
        res.append(pictos.makeSnPicto('bss')).append(' rent');
        break;
    case 'bss_put_back':
        res.append(pictos.makeSnPicto('bss')).append(' put back');
        break;
    case 'leave_parking':
        res.append(pictos.makeSnPicto('car')).append(' leave parking');
        break;
    case 'transfer':
        if (section.transfer_type === 'walking') {
            res.append(pictos.makeSnPicto('walking'));
        } else {
            res.append(document.createTextNode(section.transfer_type));
        }
        break;
    case 'on_demand_transport':
        res.append(section.type + ' ');
        pt = true;
        res.append(summary.makeRoutePoint(context, section));
        break;
    case 'public_transport':
        pt = true;
        res.append(summary.makeRoutePoint(context, section));
        break;
    case 'crow_fly':
        if (section.duration) {
            res.append(pictos.makeSnPicto(section.mode));
            res.append(sprintf(' (%s)', section.type));
        } else {
            res.append(section.type);
        }
        break;
    default: res.append(section.type); break;
    }

    if ('from' in section) {
        res.append(sprintf(' from <strong>%s</strong>', utils.htmlEncode(section.from.name)));
    }
    if (pt) {
        res.append(summary.makeSectionTime(section.departure_date_time,
                                           section.base_departure_date_time));
    }
    if ('vias' in section) {
        var via_type;
        if (section.path[section.path.length - 1].via_uri){
            via_type = 'entrance';
        }
        if (section.path[0].via_uri){
            via_type = 'exit';
        }
        res.append(summary.makeSectionVias(section.vias, via_type));
    }
    if ('to' in section) {
        res.append(sprintf(' to <strong>%s</strong>', utils.htmlEncode(section.to.name)));
    }

    if (pt) {
        res.append(summary.makeSectionTime(section.arrival_date_time,
                                           section.base_arrival_date_time));
    }
    if ('duration' in section) {
        res.append(sprintf(' during %s', utils.durationToString(section.duration)));
    }
    if (section.data_freshness && section.data_freshness !== 'base_schedule') {
        res.append(sprintf(' (%s)', section.data_freshness));
    }
    if (section.ridesharing_informations) {
        var infos = section.ridesharing_informations;
        if (infos.driver) {
            if (infos.driver.image) {
                res.append(', driver: ');
                res.append(pictos.makeImgFromUrl(infos.driver.image, infos.driver.alias));
            }
            if (infos.driver.gender && infos.driver.gender === 'male') {
                res.append(' Mr.&nbsp;');
            } else if (infos.driver.gender && infos.driver.gender === 'female') {
                res.append(' Ms.&nbsp;');
            }
            if (infos.driver.alias) {
                res.append(sprintf(' %s', infos.driver.alias));
            }
            if (infos.driver.rating &&
                infos.driver.rating.value &&
                infos.driver.rating.scale_max &&
                infos.driver.rating.scale_min &&
                infos.driver.rating.count) {
                res.append(sprintf(' %f/%f (%d reviews), ',
                                   infos.driver.rating.value - infos.driver.rating.scale_min,
                                   infos.driver.rating.scale_max - infos.driver.rating.scale_min,
                                   infos.driver.rating.count));
            }
        }
        if (infos.seats) {
            if (infos.seats.available) {
                res.append(sprintf(', available seats: %d', infos.seats.available));
            }
            if (infos.seats.total) {
                res.append(sprintf(', total seats %d', infos.seats.total));
            }
        }
        if (infos.network && infos.operator) {
            res.append(utils.htmlEncode(sprintf(', network: %s, operator: %s', infos.network, infos.operator)));
        }
    }
    return res;
};

summary.make.region = function(context, region) {
    var res = $('<span/>').text(region.id + (region.name ? sprintf(' (%s)', region.name) : ''));
    var now = new Date();
    var begin = utils.makeDate(region.start_production_date);
    var end = utils.makeDate(region.end_production_date);
    var remaining_days = Math.round((end - now) / 1000 / 60 / 60 / 24);
    if (region.error && region.error.value) {
        res.append(sprintf(', <span class="error">error: %s</span>', utils.htmlEncode(region.error.value)));
    } else if (region.status !== 'running') {
        res.append(sprintf(', <span class="error">status: %s</span>', utils.htmlEncode(region.status)));
    } else if (now < begin || end < now) {
        res.append(sprintf(', <span class="outofdate">out-of-date [%s, %s]</span>',
                           utils.formatDate(begin),
                           utils.formatDate(end)));
    } else if (remaining_days <= 21) {
        res.append(sprintf(', <span class="almost_outofdate">%sd remaining</span>', remaining_days));
    }
    return res;
};

summary.make.line = function(context, line) {
    var code = $('');
    if (line.code) {
        code = $('<span>')
            .addClass('with-bg-color')
            .append(line.code);
        summary.setColors(code, line);
    }
    return $('<span>')
        .append(pictos.makePtPicto(line.physical_modes))
        .append(code)
        .append(' ')
        .append(document.createTextNode(line.name));
};

summary.make.stop_date_time = function(context, stop_time) {
    var sum = summary.run(context, 'stop_point', stop_time.stop_point);
    var res = $('<span>')
        .append(summary.makeImpactedTime(stop_time.arrival_date_time,
                                         stop_time.base_arrival_date_time))
        .append(' > ')
        .append(summary.makeImpactedTime(stop_time.departure_date_time,
                                         stop_time.base_departure_date_time))
        .append(' ')
        .append(sum);
    return res;
};

summary.make.stop_time = function(context, stop_time) {
    var sum = summary.run(context, 'stop_point', stop_time.stop_point);
    var res = $('<span>')
        .append(summary.formatTime(stop_time.arrival_time))
        .append(' > ')
        .append(summary.formatTime(stop_time.departure_time))
        .append(' ')
        .append(sum);
    return res;
};

summary.make.departure = function(context, json) {
    var res = $('<span>');
    res.append(summary.makeImpactedTime(json.stop_date_time.departure_date_time,
                                        json.stop_date_time.base_departure_date_time));
    res.append(': ');
    res.append(summary.makeRoutePoint(context, json));
    res.append(' (' + json.stop_date_time.data_freshness + ')');
    return res;
};

summary.make.arrival = function(context, json) {
    var res = $('<span>');
    res.append(summary.makeImpactedTime(json.stop_date_time.arrival_date_time,
                                        json.stop_date_time.base_arrival_date_time));
    res.append(': ');
    res.append(summary.makeRoutePoint(context, json));
    res.append(' (' + json.stop_date_time.data_freshness + ')');
    return res;
};

summary.make.stop_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.date_time = function(context, json) {
    var res = $('<span>');
    res.append(summary.makeImpactedTime(json.date_time, json.base_date_time));
    res.append(' (' + json.data_freshness + ')');
    return res;
};

summary.make.route_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.physical_mode = function(context, json) {
    return $('<span/>')
        .append(pictos.makePtPicto(json))
        .append(document.createTextNode(' ' + json.name));
};

summary.make.connection = function(context, json) {
    return $('<span/>').text(sprintf('%s > %s, duration: %s, display_duration: %s',
                                     json.origin.id,
                                     json.destination.id,
                                     utils.durationToString(json.duration),
                                     utils.durationToString(json.display_duration)));
};

summary.make.tags = function(context, json) {
    return $('<span/>').text(json.join(', '));
};

summary.make.contributor = function(context, json) {
    var res = $('<span/>');
    var url = json.url ? json.url : json.website;
    if (url && typeof url === 'string') {
        if (url.indexOf('://') === -1) { url = 'http://' + url; }
        res.append($('<a/>').attr('href', url).text(json.name));
    } else {
        res.text(json.name);
    }
    if (json.license) {
        res.append(', license: ' + utils.htmlEncode(json.license));
    }
    return res;
};

summary.make.dataset = function(context, json) {
    return $('<span/>').text(sprintf('%s (%s - %s): [%s, %s]',
        json.description,
        json.realtime_level,
        json.system,
        summary.formatDatetime(json.start_validation_date),
        summary.formatDatetime(json.end_validation_date)
    ));
};

summary.make.stands = function(context, json) {
    return  $('<span/>').text(sprintf(
        'bikes: %d, places: %d, total: %d',
        json.available_bikes,
        json.available_places,
        json.total_stands
    ));
};

summary.make.car_park = function(context, json) {
    return $.map(['available', 'occupied', 'available_PRM', 'occupied_PRM',
            'total_places'],
        function(value) {
            if (value in json) {
                return sprintf('%s: %d', value, json[value]);
            }
    }).join(', ');
};

summary.make.disruption = function(context, json) {
    var res = $('<span/>');
    res.append($('<span/>').css('color', json.severity.color).text(json.severity.name));
    if (json.severity && json.severity.effect) {
        res.append(', effect: ' + utils.htmlEncode(json.severity.effect));
    }
    if (json.status) { res.append(', status: ' + utils.htmlEncode(json.status)); }
    if (json.cause) { res.append(', cause: ' + utils.htmlEncode(json.cause)); }
    if (json.tags && json.tags.length) { res.append(', tags: ' + json.tags); }
    return res;
};

summary.make.message = function(context, json) {
    var res = $('<span/>');
    if (json.channel.content_type === 'text/html') {
        res.html(json.text);
    } else {
        res.text(json.text);
    }
    res.prepend(sprintf('%s: ', utils.htmlEncode(json.channel.name)));
    return res;
};

summary.make.application_pattern = function(context, json) {
    var res = $('<span/>');
    var begin = utils.makeDate(json.application_period.begin);
    var end = utils.makeDate(json.application_period.end);
    var week = utils.formatWeek(json.week_pattern);

    res.text(sprintf('since %s until %s on %s', utils.formatDate(begin), utils.formatDate(end), week));
    res.append(' in ');
    res.append(summary.run(context, 'time_slots', json.time_slots));
    return res;
};

summary.make.time_slots = function(context, json) {
    var text = json.map(function(time_slot) {
        return sprintf('%s-%s', utils.formatTime(time_slot.begin), utils.formatTime(time_slot.end));
    }).join(' or ');
    return $('<span>').text(text);
};

summary.make.application_periods = function(context, json) {
    var res = $('<span/>');
    var text = json.map(function(period) {
        return sprintf('[%s, %s]',
                       summary.formatDatetime(period.begin),
                       summary.formatDatetime(period.end));
    }).join(' ∪ ');
    res.text(text);
    return res;
};

summary.make.impacted_object = function(context, json) {
    var res = $('<span>');
    if (json.impacted_section && json.pt_object.line && json.pt_object.line.code) {
        res.append('line section: ');
        var code = $('<span>')
            .addClass('with-bg-color')
            .append(json.pt_object.line.code);
        summary.setColors(code, json.pt_object.line);
        res.append(code);
        res.append(' ');
        res.append(utils.htmlEncode(json.impacted_section.from.name));
        res.append(' > ');
        res.append(utils.htmlEncode(json.impacted_section.to.name));
    } else if (json.impacted_section) {
        res.append('line section: ');
        res.append(summary.run(context, 'pt_object', json.pt_object));
        res.append(', impacted section: ');
        res.append(summary.run(context, 'impacted_section', json.impacted_section));
    } else {
        res.append(summary.run(context, 'pt_object', json.pt_object));
    }
    return res;
};

summary.make.impacted_section = function(context, json) {
    var res = $('<span>');
    res.append(summary.run(context, 'pt_object', json.from));
    res.append(' > ');
    res.append(summary.run(context, 'pt_object', json.to));

    return res;
};

summary.make.impacted_stop = function(context, json) {
    var res = $('<span>');
    res.append(summary.run(context, 'stop_point', json.stop_point));
    res.append(': ');
    res.append(summary.makeImpactedTime(json.amended_arrival_time, json.base_arrival_time));
    res.append(' > ');
    res.append(summary.makeImpactedTime(json.amended_departure_time, json.base_departure_time));
    if (json.cause) { res.append(utils.htmlEncode(', cause: ' + json.cause)); }
    return res;
};

summary.make.co2_emission = function(context, json) {
    return $('<span/>').html(sprintf('CO<sub>2</sub>:&nbsp;%.0f&nbsp;%s', json.value, json.unit));
};

summary.make.distances = function(context, json) {
    var res = $('<span/>');
    var equipments = ['walking', 'bike', 'car', 'ridesharing'];
    equipments.forEach(function(key) {
        if(json[key]) {
          $('<span>')
              .addClass('section-additional-block')
              .append(pictos.makeSnPicto(key))
              .append(utils.makeDistanceSummary(json[key]))
              .appendTo(res);
        }
    });
    return res;
};

summary.make.equipments = function(context, json) {
    var res = $('<span/>');
    json.forEach(function(equipment) {
        pictos.makeEquipmentPicto(equipment).appendTo(res);
        res.append(' ');
    });
    return res;
};

summary.make.poi = function(context, json) {
    var res = $('<span/>');
    if (json.poi_type && json.poi_type.name) {
        res.append(json.poi_type.name + ': ');
    }
    res.append(json.label);
    if (json.stands) {
        res.append(', stands: ');
        if (!json.stands.status || json.stands.status === 'open') {
            res.append(summary.run(context, 'stands', json.stands));
        } else {
            res.append($('<span/>')
                        .addClass('stands-status')
                        .addClass(json.stands.status)
                        .text(json.stands.status));
        }
    }

    if (json.car_park) {
        res.append(', car park: ');
        res.append(summary.run(context, 'car_park', json.car_park));
    }
    return res;
};

summary.make.traffic_report = function(context, json) {
    var r = $.map(json, function(obj, key) {
        if (obj.length) {
            return sprintf('%d %s', obj.length, key);
        }
    });
    if (r.length) {
        return sprintf('network %s: %s', json.network.name, r.join(', '));
    } else {
        return sprintf('network %s: no disruption', json.network.name);
    }
};

summary.make.line_report = function(context, json) {
    return $('<span>')
        .append('line: ')
        .append(summary.run(context, 'line', json.line))
        .append(sprintf(', %d pt_objects', json.pt_objects.length));
};

summary.make.equipment_report = function(context, json) {
    return $('<span>')
        .append('line: ')
        .append(summary.run(context, 'line', json.line))
        .append(sprintf(', %d stop_area_equipments', (json.stop_area_equipments || []).length));
};

summary.make.terminus_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.free_floating = function(context, json) {
    var res = $('<span/>');
    function add(s, n) {
        res.append(sprintf(', %s: ',s));
        $('<span/>')
            .addClass('gray-and-bold')
            .text(sprintf('%s', n))
        .appendTo(res);
    }
    res.append(sprintf('%s', json.type));
    add('provider', json.provider_name);
    res.append(', distance: ');
    $('<span/>')
        .addClass('gray-and-bold')
        .text(sprintf('%s m', json.distance))
    .appendTo(res);
    if (json.public_id) {
        add('public id', json.public_id);
    }
    if (json.battery) {
        add('battery', json.battery);
    }
    return res;
};

summary.make.stop_area_equipment = function(context, json) {
    var equip_details = (json.equipment_details || []);
    var res = $('<span>')
        .append('stop_area: ')
        .append(summary.run(context, 'stop_area', json.stop_area))
        .append(sprintf(', %d equipments', equip_details.length));

    var unavailable_equipments = equip_details.filter(function(o){
        return o.current_availability.status === 'unavailable';
    }).length;
    if(unavailable_equipments) {
        res.append($('<span/>').addClass('unavailable').text(' ('+unavailable_equipments+' unavailable)'));
    }

    return res;
};

summary.make.equipment_detail = function(context, json) {
    var res = $('<span/>')
        .append(json.name || json.id).append(', ')
        .append('type: '+ json.embedded_type);

    var cur_avail = json.current_availability;
    if (cur_avail) {
        if(cur_avail.status) {
            var status_class = ['unavailable', 'available'].find(function(o){ return o === cur_avail.status;}) || 'unknown';
            res.append(', status: ');
            res.append($('<span/>').addClass(status_class).text(cur_avail.status));
        }
        if(cur_avail.cause){
            res.append(', cause : ' + utils.htmlEncode(cur_avail.cause.label));
        }
        if(cur_avail.effect) {
            res.append(', effect : ' + utils.htmlEncode(cur_avail.effect.label));
        }
    }
    return res;
};

summary.make.path = function(context, json) {
    var res = $('<span>')
        .append(pictos.makeSnPicto(json.mode))
        .append(' > ')
        .append(sprintf('%d paths', json.path.length));
    return res;
};

summary.make.instruction = function(context, path_item) {
    var res = $('<span>');
        if (path_item.instruction) {
            res.append(path_item.instruction);
        } else {
            if (path_item.direction === parseInt('0',10)) {
                res.append('Continue on ');
            } else if (path_item.direction < parseInt('0', 10)){
                res.append('Turn left onto ');
            } else {
                res.append('Turn right onto ');
            }
            if (path_item.name === '') {
                $('<span/>')
                    .addClass('street')
                    .text('Street Name Unknown')
                .appendTo(res);
            } else {
                $('<span/>')
                    .addClass('street')
                    .text(path_item.name)
                .appendTo(res);
            }
            res.append('. Go for ');
            $('<span/>')
                .addClass('length')
                .text(sprintf('%s m.',path_item.length))
            .appendTo(res);
        }
        res.append(' (duration: ');
        res.append(path_item.duration);
        res.append(' s)');
    return res;
};

summary.make.note = function(context, json) {
    return json.value;
};

summary.make.elevations = function(context, json) {
    /*
    0%: A flat road
    1-3%: Slightly uphill but not particularly challenging. A bit like riding into the wind.
    4-6%: A manageable gradient that can cause fatigue over long periods.
    7-9%: Starting to become uncomfortable for seasoned riders, and very challenging for new climbers.
    10%-15%: A painful gradient, especially if maintained for any length of time
    16%+: Very challenging for riders of all abilities. Maintaining this sort of incline for any length of time is very painful.
    */

    // we consider a slope is steep if the angle is larger than 5° ~= 10.45%
    var going_up = 0;
    var going_down = 0;

    var steep_ascending_slope = 0;
    var steep_descending_slope = 0;

    var steep_threshold = Math.sin(5.0 * Math.PI / 180.0);

    json.forEach(function(element, index, array) {
        if (index === 0) {
            return;
        }
        var ele_diff = array[index].elevation - array[index-1].elevation;
        var dis = array[index].distance_from_start - array[index-1].distance_from_start;

        if (ele_diff > 0) {
            going_up += ele_diff;
            if ((ele_diff / parseFloat(dis)) > steep_threshold) {
                steep_ascending_slope += dis;
            }
        }
        if (ele_diff < 0) {
            going_down += -ele_diff;
            if (((-ele_diff) / parseFloat(dis)) > steep_threshold) {
                steep_descending_slope += dis;
            }
        }

    });
    return sprintf('Elevation Climbed: %sm, Elevation Dropped: %sm, Steep Ascending: %sm, Steep Descending: %sm ',
        going_up, going_down, steep_ascending_slope, steep_descending_slope);
};

summary.make.context = function(context, json) {
    var res = $('<span>').text(sprintf('current datetime: %s, timezone: %s',
                                       summary.formatDatetime(json.current_datetime),
                                       json.timezone));
    if (json.car_direct_path && json.car_direct_path.co2_emission.value) {
        res.append(sprintf(', car '));
        res.append(summary.run(context, 'co2_emission', json.car_direct_path.co2_emission));
    }
    return res;
};

summary.make.via = function(context, ap) {
    var res = $('<span/>');
    res.append('name: ');
    if (ap.name) {
        $('<span/>')
            .addClass('street')
            .text(ap.name)
            .appendTo(res);
    }
    res.append(' - ');
    res.append('properties (');
    if (ap.is_entrance && ap.is_entrance === true) {
        res.append('is entrance');
    }
    res.append(' - ');
    if (ap.is_exit && ap.is_exit === true) {
        res.append('is exit');
    }
    res.append(') - ');
    res.append('length: ');
    if (ap.length) {
        $('<span/>')
            .addClass('street')
            .text(sprintf('%s m', ap.length))
            .appendTo(res);
    }
    res.append(' - ');
    res.append('traversal time: ');
    if (ap.traversal_time) {
        $('<span/>')
            .addClass('street')
            .text(sprintf('%s s', ap.traversal_time))
            .appendTo(res);
    }
    return res;
};


// add your summary view by adding:
//   summary.make.{type} = function(context, json) { ... }

summary.setColors = function(elt, json) {
    if ('color' in json) {
        elt.css('background-color', '#' + json.color);
        elt.css('color', utils.getTextColor(json));
    }
};

summary.defaultSummary = function(context, type, json) {
    if (! (json instanceof Object)) { return 'Invalid object'; }

    var res = $('<span/>');
    if ('physical_modes' in json && $.isArray(json.physical_modes)) {
        json.physical_modes.forEach(function(mode) {
            res.append(pictos.makePtPicto(mode));
        });
    }
    if ('label' in json) {
        res.append(document.createTextNode(json.label));
    } else if ('name' in json) {
        res.append(document.createTextNode(json.name));
    } else if ('id' in json) {
        res.append(document.createTextNode(json.id));
    } else {
        res.append('no summary');
    }
    return res;
};

summary.formatDatetime = function(datetime) {
    if (typeof datetime !== 'string') { return 'none'; }
    var formated = datetime.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/,
                                    '$1-$2-$3 $4:$5:$6');
    if (formated.slice(-2) === '00') {
        return formated.slice(0, -3);
    } else {
        return formated;
    }
};

summary.formatTime = function(datetime) {
    if (datetime.length === 6) {
        var formated = datetime.replace(/(\d{2})(\d{2})(\d{2})/, '$1:$2:$3');
        if (formated.slice(-2) === '00') {
            return formated.slice(0, -3);
        } else {
            return formated;
        }
    }
    return summary.formatDatetime(datetime).split(' ')[1];
};

summary.makeSectionTime = function(dt, baseDt) {
    var res = $('<span/>');
    res.append(' at ');
    if (baseDt && baseDt !== dt) {
        res.append($('<span/>').addClass('old-datetime').text(summary.formatTime(baseDt)));
    }
    res.append(sprintf(' %s', summary.formatTime(dt)));
    return res;
};

summary.makeSectionVias = function(vias, via_type) {
    var res = $('<span/>');
    res.append(' via ');
    vias.forEach(function(v){
        res.append($('<span/>'));
        res.append(pictos.makeSnPicto(via_type));
        res.append(sprintf('  <strong>%s</strong>', utils.htmlEncode(v.access_point.name)));
    });
    return res;
};


summary.makeImpactedTime = function(amended, base) {
    var res = $('<span/>');
    if (base && base !== amended) {
        res.append($('<span/>').addClass('old-datetime').text(summary.formatTime(base)));
        res.append(' ');
    }
    if (amended) {
        res.append(utils.htmlEncode(summary.formatTime(amended)));
    }
    return res;
};

summary.makePhysicalModesFromSection = function(section) {
    if ('links' in section) {
        var pms = section.links
            .map(function(o) {
                if (o.type === 'physical_mode') {
                    return { id: o.id, name: section.display_informations.physical_mode };
                } else {
                    return null;
                }
            });
        return pictos.makePtPicto(pms);
    }
};

summary.makeLineCode = function(display_informations) {
    if (! display_informations.code) { return $(''); }
    var elt = $('<span>')
        .addClass('with-bg-color')
        .append(display_informations.code);
    summary.setColors(elt, display_informations);
    return elt;
};

summary.makeRoutePoint = function(context, json) {
    var res = $('<span/>');
    if ('route' in json) {
        res.append(pictos.makePtPicto(json.route.physical_modes));
    } else if ('links' in json && 'display_informations' in json) {
        res.append(summary.makePhysicalModesFromSection(json));
    }
    res.append(summary.makeLineCode(json.display_informations));
    res.append(' > ');
    res.append(json.display_informations.direction);
    if (json.stop_point) {
        res.append(' at ');
        res.append(summary.run(context, 'stop_point', json.stop_point));
    }
    return res;
};

summary.makeVehiclePosition = function(context, json) {
    var res = $('<span/>');
    res.append(summary.run(context, 'line', json.line));
    return res;
};

summary.make.vehicle_position = function(context, json) {
    if (json.line) {
        return summary.makeVehiclePosition(context, json);
    } else {
        return summary.makeVehicleJourneyPosition(context, json);
    }
};

summary.make.vehicle_journey_position = function(context, json) {
    return summary.makeVehicleJourneyPosition(context, json);
};


summary.makeVehicleJourneyPosition = function(context, json) {
    var res = $('<span>');
    res.append(json.vehicle_journey.name);
    if (json.occupancy) {
        res.append(' > Occupancy: ');
        res.append(json.occupancy);
    }
    return res;
};

summary.run = function(context, type, json) {
    var res;
    try {
        if (type in summary.make) {
            res = summary.make[type](context, json);
        } else {
            res = summary.defaultSummary(context, type, json);
        }
    } catch (e) {
        console.log(sprintf('summary(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        res = 'summary error';
    }
    if (res instanceof jQuery) {
        return res.get(0);
    } else if (typeof res === 'string') {
        return $('<span>').text(res).get(0);
    }
    return res;
};


// Copyright (c) 2016 Hove
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var summary;
var response;

var utils = {};

utils.isDatetimeType = function(str) {
    return $.inArray(str, ['since', 'until']) !== -1 || str.match(/datetime$/);
};

utils.htmlEncode = function(value) {
    return $('<div/>').text(value).html();
};

utils.durationToString = function(duration) {
    var res = '';
    var seconds = duration % 60;
    var minutes = Math.floor(duration / 60) % 60;
    var hours = Math.floor(duration / (60 * 60)) % 24;
    var days = Math.floor(duration / (24 * 60 * 60));

    if (days !== 0) { res += sprintf('%sd', days); }
    if (hours !== 0) { res += sprintf('%sh', hours); }
    if (minutes !== 0) { res += sprintf('%smin', minutes); }
    if (seconds !== 0) { res += sprintf('%ss', seconds); }

    if (! res) {
        return '0s';
    } else {
        return res;
    }
};

utils.isTemplate = function(str) {
    return str.slice(0, 1) === '{' && str.slice(-1) === '}';
};

utils.flatMap = function(array, f) {
    var result = [];

    array.forEach(function(obj, i, array) {
        result = result.concat(f(obj, i, array));
    });
    return result;
};

$.notify.addStyle('navitia', {
    html: '<div class="ui-widget"><span data-notify-html="text"></span></div>',
    classes: {
        error: {
            'color': '#B94A48',
            'background-color': '#F2DEDE',
            'border-color': '#EED3D7',
        },
        success: {
            'color': '#468847',
            'background-color': '#DFF0D8',
            'border-color': '#D6E9C6',
        },
        info: {
            'color': '#3A87AD',
            'background-color': '#D9EDF7',
            'border-color': '#BCE8F1',
        },
        warn: {
            'color': '#C09853',
            'background-color': '#FCF8E3',
            'border-color': '#FBEED5',
        }
    }
});

utils.errorMessage = function(url, xhr, status/*, error*/) {
    var message;
    if (url.lastIndexOf('http:', 0) === 0 && window.location.protocol === 'https:') {
        message = $('<span>').text(
            'You cannot request the API using http if ' +
                'you are connected to navitia-playground ' +
                'using https.  Please request the API using ' +
                'https or connect to navitia-playground ' +
                'using http.');
    } else if (xhr.readyState === 0) {
        message = $('<span>').text('Network error');
    } else if (xhr.responseJSON) {
        message = $(summary.run(new response.Context(xhr.responseJSON),
                                'response',
                                xhr.responseJSON));
    } else {
        message = $('<span>').text(status);
    }
    return message;
};

utils.notifyOnError = function(typeError, url, xhr, status, error) {
    if (xhr.status === 401) {
        $('#token').addClass('templateInput');
    }
    var message = utils.errorMessage(url, xhr, status, error);
    $.notify({
        text: $('<span/>').text(sprintf('%s error: ', typeError)).append(message)
    }, {
        position: 'right bottom',
        style: 'navitia',
    });
};

utils.notifyWarn = function(message) {
    $.notify({
        text: message
    }, {
        position: 'right bottom',
        className: 'warn',
        style: 'navitia',
    });
};

utils.notifyInfo = function(message) {
    $.notify({
        text: message
    }, {
        position: 'right bottom',
        className: 'info',
        style: 'navitia',
    });
};

utils.getType = function(key) {
    if (!key || typeof key !== 'string') {
        return null;
    }
    // hardcoded cases:
    switch (key) {
    case 'places_nearby': return 'place';
    case 'addresses': return 'address';
    case 'from': return 'place';
    case 'to': return 'place';
    }
    // generic plural
    if (key.slice(-1) === 's') { return key.slice(0, -1); }

    // just the key
    return key;
};

utils.getTextColor = function(json) {
    function _toNum(c, i) { return +('0x' + c.slice(i, i + 2)); }

    if (json.text_color) {
        return '#' + json.text_color;
    }
    if (json.color) {
        var c = json.color;
        var grey = 0.21 * _toNum(c, 0) + 0.72 * _toNum(c, 2) + 0.07 * _toNum(c, 4);
        if (grey < 128) {
            return 'white';
        }
    }
    return 'black';
};

utils.computeColorFromRatio = function(ratio) {
    var r = 255;
    var g = 255;
    if (ratio < 1/2) {
        r = Math.ceil(255 * ratio * 2);
    } else {
        g = Math.ceil(255 * (1 - ratio) * 2);
    }
    return {red: r, green: g, blue: 0};
};

utils.toCssColor = function(c, alpha) {
    if (alpha) {
        return sprintf('rgba(%s, %s, %s, %s)', c.red, c.green, c.blue, alpha);
    } else {
        return sprintf('#%02x%02x%02x', c.red, c.green, c.blue);
    }
};

utils.getColorFromRatio = function(ratio) {
    return utils.toCssColor(utils.computeColorFromRatio(ratio));
};

utils.manageToken = function(token) {
  return token ? { Authorization: 'Basic ' + btoa(token + ':') } : {};
};

utils.deepClone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
};

utils.makeDistanceSummary = function(d) {
  var format = '%f&nbsp;%s';
  if (d >= 1000) { return sprintf(format, d / 1000.0, 'km'); }
  return sprintf(format, d, 'm');
};

utils.makeDate = function(d) {
        if (typeof d !== 'string') { return null; }
        var year = + d.slice(0, 4);
        var month = + d.slice(4, 6) - 1;
        var day = + d.slice(6, 8);
        return new Date(year, month, day);
};

utils.formatTime = function(time) {
        if (typeof time !== 'string') { return null; }
        var hour = time.slice(0, 2);
        var minute = time.slice(2, 4);
        var second = time.slice(4, 6);
        return sprintf('%s:%s:%s', hour, minute, second);
};

utils.formatDate = function(d) {
        if (!(d instanceof Date)) { return '???'; }
        return sprintf('%04d-%02d-%02d', d.getFullYear(), d.getMonth() + 1, d.getDate());
};

utils.formatWeek = function(week_pattern) {
    var result = [];
    if (week_pattern.sunday === true){ result.push('Sun');}
    if (week_pattern.monday === true){ result.push('Mon');}
    if (week_pattern.tuesday === true){ result.push('Tues');}
    if (week_pattern.wednesday === true){ result.push('Wed');}
    if (week_pattern.thursday === true){ result.push('Thurs');}
    if (week_pattern.friday === true){ result.push('Fri');}
    if (week_pattern.saturday === true){ result.push('Sat');}
    return result.join(', ');
};
